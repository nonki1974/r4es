---
title: "Rによるデータ解析入門"
author: "Tomokazu FUJINO (@nonki1974)"
site: bookdown::bookdown_site
output:
  bookdown::gitbook:
    split_by: section
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Rの基礎（データ構造とデータ型）{#Rbasics}

ここでは、データは数値や文字の集まりであると考えます。Rで標準的に利用できるデータの格納方法（データ構造）は以下の4つです。

- **ベクトル**（vector）
- **配列・行列**（array, matrix）
- **リスト**（list）
- **データフレーム**（data frame）

一方、個々のデータそのものの種類をデータ型と呼び、Rでは主に以下の3つを利用します。

- **数値型**（numeric）
- **文字型**（charater）
- **因子型**（factor）

特に、因子型は他のプログラミング言語にはないデータ型で、統計解析環境であるRならではのデータ型となっています。

## データ構造（1）ベクトル {#vector}

Rにおける最もシンプルなデータ構造が**ベクトル**です。Rにおいては、単一の数値であっても、大きさ1のベクトルとして扱われます。例えば、以下のような演算を実行した結果の数値も大きさ1のベクトルです。結果に表示される`[1]`はそのすぐ右にある数値がベクトルの1番目の要素であることを示しています。

```{r}
3+4
sqrt(9)
sin(pi/6)
```

多くの要素を持つベクトルの場合、例えば正規乱数を12個生成した結果のベクトルは以下のように表示されます。

```{r}
rnorm(12)
```

### オブジェクトと変数 {#object_and_var}

Rのコンソールにコマンドを入力すると、Rは何らかの結果をベクトルなどの形で出力してくれます。これらを総称して**オブジェクト**と呼びます。上のようなコマンドでは出力された結果のオブジェクトは再利用できませんが、**変数**に代入することで、再利用することができます。例えば、

```{r}
x <- rnorm(12)
```

とすると、実行結果には何も表示されませんが、変数`x`の中に実行結果が格納されます。`<-`（代入演算子と呼びます）は、左辺の変数に右辺の実行結果を代入しなさいという意味になります。つまり、`x`に`rnorm(12)`の結果のオブジェクトが格納されたということになります。`x`の中に何が入っているかを知りたい場合は、コンソールに`x`と入力します。

```{r}
x
```

変数名には、文字、数字、ピリオドなどの記号が利用できますが先頭に数字がつくものは使えません。また、**大文字と小文字を区別します**ので、注意しましょう。実際に分析するときは、分析者にとって分かりやすく、また複数の分析者で分析する場合は他の人が見てもある程度推測できるような変数名にするとよいです。

```{r}
student_id <- 1200
```

任意のベクトルを作成する場合は、`c()`関数^[cはcombineのcを意味している]を用います。

```{r}
x <- c(3, 6, 10)
x
y <- c(sin(pi/6), sqrt(9))
y
```

### 便利なベクトル作成法 {#usefulfunctionforgeneratingvec}

規則的に並んだ数値を要素とするベクトルを作成するには、いくつかの便利な方法があります。

```{r}
# 1ずつ増加する数列
1:10
# 同じ数値の繰り返し
rep(10, 5)
# 増分を指定した数列（任意の公差をもつ等差数列）
seq(1, 2, 0.1)
```

### ベクトルの演算 {#operator_for_vec}

ベクトル同士の演算は、2つのベクトルの大きさが同じ場合には要素同士の演算結果がベクトルとして返されます。

```{r}
x <- c(3, 6, 10)
y <- c(3, 2, 5)
x + y
x - y
x * y
x / y
```

2つのベクトルの大きさが異なる場合には、小さい方のベクトルの要素が、大きい方と同じ大きさになるまで「リサイクル」されます。以下のコマンドは`x^c(2, 2, 2)`と同じであると理解しましょう。

```{r}
x^2
```

以下のように、大きい方のベクトルの大きさが、小さい方の大きさの定数倍でない場合には警告が出力されます。

```{r}
z <- c(1, 2)
x * z
```

### ベクトルの要素の参照 {#reference_for_element}

ベクトルの要素を参照する場合は、`[]`を以下のように使います。

```{r}
x[2]
x[2:3]
x[c(1, 3)]
```

### ベクトルに対する便利な関数 {#useful_function_for_vec}

複数の処理をまとめたものを**関数**（function）といいます。関数にはRに元々組み込まれているものもありますし、自分で関数を作ることもできます。関数は `関数名()` の形式で呼び出すことができ、`()`内にオブジェクトを記述することで、関数はそのオブジェクトに対して定められた処理を実行します。`()`内に記述するオブジェクトを**引数**（ひきすう）と呼びます。

ベクトルに対しては、以下のような関数がよく用いられます。

```{r}
# ベクトルの大きさ（要素数）を出力する
length(x)
# 数値ベクトルの合計を出力する
sum(x)
# 数値ベクトルの平均を出力する
mean(x)
# 数値ベクトルの標準偏差（standard deviation）を出力する
sd(x)
```


## データ型 {#datatype}

### 数値型と文字型 {#numeric_and_char}

これまで扱ってきたベクトルに格納しているデータはすべて**数値型**（numeric）でした。Rでは文字列もデータとして扱うことができ、**文字型**（character）のデータと呼びます。文字型のデータはダブルクォート`"`で囲むことによって表現します。

```{r}
s <- c("Kasumi", "Nadeshiko", "Kashii")
s
```

**ベクトルは、異なるデータ型を混在させることはできません。**数値型と文字型が混在したベクトルを作成しようとすると、数値型が文字型に強制変換されます。

```{r}
c("Happy", "New", "Year", 2021)
```

`class()`関数によってオブジェクトの型を確認することができます。

```{r}
class(x)
class(s)
```

### 因子型 {#factor}

統計データを扱うR言語独特のデータ型として、**因子型（factor）**があります。統計学においては、データをその性質から

- 名義尺度：分類コードやIDとして用いられる数値（血液型や性別など）
- 順序尺度：名義尺度に順序に関する情報が追加された数値（成績など）
- 間隔尺度：差の演算結果に意味がある数値（摂氏の気温など）
- 比例尺度：比の演算結果に意味がある数値（長さ重さなど、0が何もないを表すもの）

の4種類に分類するという考え方が一般的です。名義尺度と順序尺度の値を持つ変数のことを**質的変数**と呼び、因子型は質的変数を扱うためのデータ型となっています。

```{r}
# 数値型から因子型ベクトルを作成
hakata <- c(0, 2, 3, 1, 3, 2, 1, 2)
fhakata <- factor(hakata, levels = 0:3)
fhakata
as.numeric(fhakata)
as.numeric(as.character(fhakata))
```

この例では、最初に数値型のベクトルを作成し、それを`factor()`関数で因子型のベクトルに変換しています。`factor()`関数の`levels`引数は、**水準集合**のベクトルを指定します。この場合、0という数値が1番目の水準に、1という数値が2番目の水準というように割り当てられることを意味します。

因子型のベクトルの場合、内容を表示すると`Levels`の行のように水準集合が合わせて表示されるので、これでデータが因子型かどうかを見分けることができます。`as.numeric()`関数で因子型ベクトルを数値型ベクトルに変換すると、水準番号が出力されます。元のデータを出力する場合には、`as.character()`関数で一旦文字型ベクトルに変換してから、数値型ベクトルに変換します。

`levels`関数を使うと、水準集合を参照したり更新したりすることができます。

```{r}
levels(fhakata)
levels(fhakata) <- c("天ぷら", "もつ鍋", "ラーメン", "ごまさば")
fhakata
as.numeric(fhakata)
```

質的変数のデータは、元々は文字列として記録されていることが多いかもしれません。文字型ベクトルを`factor()`関数で因子型に変換すると、出現した要素全てが水準集合に含まれるようになります。

```{r}
fhakata_char <- c("天ぷら", "もつ鍋", "ラーメン", "ごまさば", "ラーメン")
factor(fhakata_char)
```

### 論理型

`TRUE`と`FALSE`あるいはそれらの省略形として`T`と`F`は、**論理型（logical）**と呼ばれるデータ型の値であり、それぞれ真（True）と偽（False）を表現するために用いられます^[ダブルクォートがついていないので文字型ではないことに注意]。

```{r}
logical_sample <- c(TRUE, FALSE, T, T, F, F)
logical_sample
```

### 欠損値の表現について

実際に統計データを扱う際には、何らかの理由で一部のデータが観測されなかったり、個人情報保護の目的で一部のデータが提供されていなかったりすることがあります。このようなデータを表現するために、Rでは欠損値を意味する値`NA`が用いられます。

```{r}
x <- c(2, 5, 10, NA, 3, 2)
x
```

`NA`を含んだベクトルに対して演算や集計をした場合は次のようになります。

```{r}
y <- 1:6
x + y
sum(x)
mean(x)
```

`sum()`関数や`mean()`関数で欠損値を無視して計算したい場合には、引数で`na.rm = TRUE`を指定します。

```{r}
sum(x, na.rm = TRUE)
mean(x, na.rm = TRUE)
```

因子型ベクトルを作成するとき、数値型のベクトルに水準集合に含まれない要素がある場合には、因子型ベクトルの中では欠損値として扱われます。

```{r}
factor(c(2, 3, 5, 2), levels = 1:4)
```


## データ構造（2）配列と行列 {#arrayandmatrix}

ベクトルに次元属性を与えることにより、配列として扱えるようになります。

```{r}
x <- 1:9
x
# xを3x3の2次元配列（行列）として扱う
dim(x) <- c(3, 3)
x

x3 <- 1:27
# x3を3x3x3の3次元配列として扱う
dim(x3) <- c(3, 3, 3)
x3
```
`dim()`関数により次元属性が与えられ、引数には各次元の要素数を指定します。配列の各要素は、各次元の要素番号を指定しても、ベクトルとしての要素番号を指定しても参照できます。
```{r}
x3[1, 2, 1]
x3[4]
```
特に2次元配列である行列を作成する場合には、`matrix()`関数を使うことができます。
```{r}
matrix(1:15, ncol = 5, byrow = TRUE)
```
最初の引数でベクトルを指定します`ncol`は行列の列数、`byrow`は行方向にベクトルの要素を並べるかどうかを`TRUE`か`FALSE`で指定します（デフォルトは`FALSE`）。

## データ構造（3）リスト {#list}

ベクトルは単一のデータ型しか保持できませんが、異なるデータ型のベクトルの集まりを1つのオブジェクトとして扱えるデータ構造を**リスト**といいます。リストは、ベクトルだけでなく、別のリストも要素として持つことができます。

```{r}
season <- 2013
pacific <- c("楽天", "西武", "ロッテ", "ソフトバンク", "オリックス", "日本ハム")
central <- c("巨人", "阪神", "広島", "中日", "DeNA", "ヤクルト")
npb <- list(pacific = pacific, central = central, season = season)
npb
```

リストを新たに作成するには`list()`関数を用います。引数は、`要素の参照名 = オブジェクト`をカンマ区切りで列挙します。リストのオブジェクト名の後に`$要素の参照名`をつけて実行すると、指定したリストの要素を直接参照できます。例えば、
```{r}
npb$pacific
```
また、`npb[[1]]`のようにすれば、要素番号でリストの要素を参照することもできます。
```{r}
npb[[2]]
```
以下のようにして、文字列として参照名を指定することもできますが、この場合の結果はリストとなります。
```{r}
npb["central"]
class(npb["central"])
```
統計計算などを行うRの関数の多くは、その結果をリストの形式で返します。リストの要素の参照名の一覧を見るには`names()`関数を用います。
```{r}
names(npb)
```
また、リストの構造を見たい場合は、`str()`関数を用います。
```{r}
str(npb)
```

## データ構造（4）データフレーム {#dataframe}

**データフレーム**は、同じ長さの複数のベクトルを要素とするリストで、表形式のデータを扱うためのデータ構造です。行列と違い、各列のデータ型は異なっても構いません。データフレームの各行を**個体**、各列を**変数**と呼びます。データフレームを作成するには、`data.frame()`関数を用います。引数は`list()`関数と同様です。

```{r}
pacific_seiseki <- data.frame(pacific = pacific,
                              win = c(82, 74, 74, 73, 66, 64),
                              lose = c(59, 66, 68, 69, 73, 78))
pacific_seiseki
```

リストと同様に、データフレームの列を参照することができます。`$`で列名を指定すれば、その列のベクトルが返され、`["列名"]`の形式で列名を指定すれば、1列のデータフレームとして結果が返されます。

```{r}
pacific_seiseki$win
pacific_seiseki["lose"]
```

リストと異なる点は、行列の要素と同様の参照が利用できることです。

```{r}
# 要素の参照
pacific_seiseki[2, 3]
# 行の参照
pacific_seiseki[4, ]
# 列の参照
pacific_seiseki[, 3]
# 複数列の参照: 2列目から3列目
pacific_seiseki[, 2:3]
# 複数列の参照: 1列目と3列目
pacific_seiseki[, c(1, 3)]
```

データフレームの行数と列数は以下のようにして確認することができます。

```{r}
# 行数
nrow(pacific_seiseki)
# 列数
ncol(pacific_seiseki)
# 同時に
dim(pacific_seiseki)
```

RStudioを利用している場合、Environment Paneにオブジェクトの一覧が表示されますが、その中でデータフレームのオブジェクトをクリックすると、スプレッドシートの形式で、データのプレビューが表示され、簡易的なデータの検索やソートができます。

### 外部データのデータフレームへのインポート {#readcsv}

これまでは、Rの基本的な説明のために、ベクトルやデータフレームのオブジェクトをコマンドで作成する方法を示してきましたが、実際の分析では既存の外部データをRにインポートすることが多いです。ここでは、CSVファイルをインポートする方法を紹介します。

[`fukuoka2015.csv`](https://raw.githubusercontent.com/nonki1974/r4es/master/data/fukuoka2015.csv)は2015年の福岡県内市区町村の人口および世帯数のデータです。リンクをクリックするととブラウザでファイルの中身が表示されるので、作業ディレクトリ（プロジェクトフォルダの場所）に「data」というフォルダを作成して、その中に保存しておいてください（右クリック->「名前を付けて保存」）。CSVファイルをデータフレームとしてインポートするには、`read.csv()`関数を用います。

```{r}
fukuoka2015 <- read.csv("./data/fukuoka2015.csv", encoding = "UTF-8")
# データフレームの最初の6行を表示
head(fukuoka2015)
```
`encoding`引数に、読み込むファイルの文字コード（このファイルの場合`UTF-8`）を指定します。この引数を指定しない場合、システム標準の文字コード（Windowsの場合`SHIFT-JIS`、Macの場合`UTF-8`）で読み込まれます。ファイルの文字コードと読み込もうとする文字コードに相違がある場合、文字化けが発生します。`UTF-8`のファイルを読み込む場合、Macの環境では、`encoding`引数の指定は必要ありません。

特に引数を指定しない場合、csvファイルの中で、数値のみからなるの列は数値型、それ以外は文字型として読み込まれます。`fukuoka2015`の場合、`area_code`はコード番号を表すので名義尺度ですが、数値型として読み込まれるので、必要に応じて因子型に変換します。また、`地域`は文字型として読み込まれるので、こちらも必要に応じて因子型に変換します（後述）。

```{r}
str(fukuoka2015)
```



