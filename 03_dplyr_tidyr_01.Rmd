# dplyr/tidyrを用いたデータの整理と変換(1) {#dplyr_tidyr_01}

## パッケージによる機能拡張 {#package}

Rの特徴として、パッケージによって様々な機能を拡張できる点が挙げられます。パッケージのインストールには、`install.packages()`関数を用います。例えば、この後で利用する**dplyr**パッケージをインストールするには、以下のようにします。

```{r eval=FALSE}
install.packages("dplyr")
```

パッケージのインストールは、Rを利用するPCで1度だけ実行しておけば十分です^[定期的にアップデートは必要。Rのメジャーバージョン（例えば4.0.2の場合は"4"）が上がった場合は、インストールが必要）]。

パッケージで提供されている関数を利用する場合には、セッションごとに`library()`関数を実行しておく必要があります。

```{r eval=FALSE}
library(dplyr)
```

これを実行しない場合、関数をパッケージ名と共に`dplyr::filter()`のような形式で用いる必要があります。実行した場合は、単に`filter()`とすれば利用できます。

ただし、**dplyr**パッケージは後述の**tidyverse**で合わせてインストールされますので、ここでは上記コマンドの実行は不要です。


## tidyverse

**tidyverse**とは、**tidy data**（整然データ、整理データ）を軸としたデータサイエンスプロジェクトのためのパッケージ群です。tidyverseをインストールすると多くのパッケージがインストールされますが、主要なパッケージとしては以下のようなものになります。

- **dplyr** : データの操作に関する一貫した文法を持つ関数を提供する
- **ggplot2**：*Grammer of Graphics*（グラフィックスの文法）に基づいて統計グラフを出力するための関数を提供する
- **tidyr**：tidy dataを得るために必要な関数を提供する
- **readr**：長方形のデータ（`csv`、`tsv`や`fwf`など）を高速に読み込むための関数を提供する
- **purr**：Rにおける関数型プログラミング環境を提供する
- **tibble**：データフレームを拡張したクラスを提供する
- **stringr**：文字列処理を簡単に実行するための関数を提供する
- **forcats**：因子型を効率的に処理するための関数を提供する

これらのパッケージが提供する関数は

```{r eval=FALSE}
library(tidyverse)
```

とすることで、一括して直接利用できるようになります。

## nycflights13

ここでは、**nycflights13**パッケージで提供されている`flights`データを利用して各種機能の解説や演習を行っていきます。パッケージのインストールは以下のように行います。

```{r eval=FALSE}
install.packages("nycflights13")
```

データを利用するには

```{r}
library(nycflights13)
```
としておきます。

```{r echo=FALSE}
pacman::p_load(tidyverse, nycflights13)
```

`flights`にデータが格納されています。`flights`データは、データフレームを拡張した**tibble**という形式となっていますが、ほとんどの場合データフレームと同じ扱い方で問題ありません^[そうでない場合も一部あります。]。データフレームの場合、以下のようにオブジェクトの中身を出力するとすべてが出力されますが、tibbleの場合、最初の10行のみと、コンソールに入る列数分の変数が表示され、データの下に残りの行数と変数の数と変数名と変数の型が表示されます。

```{r}
flights
```

`flights`データには、2013年にニューヨークの各空港を離陸したすべてのフライトに関する情報が記録されています。変数の一覧を表に示します。

|列名|内容|列名|内容|
|:------|:------|:------|:------|
|`year`|年|`tailnum`|機体番号|
|`month`|月|`flight`|便名|
|`day`|日|`origin`|出発地|
|`dep_time`|離陸時刻|`dest`|到着地|
|`dep_delay`|離陸遅延時間[分]|`air_time`|飛行時間[分]|
|`arr_time`|到着時刻|`distance`|飛行距離|
|`arr_delay`|到着遅延時間[分]|`hour`|離陸時刻[時]|
|`carrier`|航空会社省略名|`minute`|離陸時刻[分]|
|`time_hour`|出発予定時刻|

## 1つのテーブルに対するverb {#onetable_verbs}

**dplyr**パッケージはデータの操作に関する一貫した文法を持つ関数を提供しています。このパッケージにおいて、テーブル（データフレームやtibbleなど）に対して何らかの処理を行う関数のことを**verb**と呼びます。verbは以下のようなルールで用いられます。

- 最初の引数は処理対象となるテーブル
- 2番目以降の引数で、verbに関連するオプションを指定
- 帰ってくる値は常にテーブル

verbの説明のために、以下のように簡単なデータフレームを作成しておきます。

```{r}
df <- data.frame(
  color = c("blue", "black", "blue", "blue", "black"),
  value = 1:5
)
df
```

### 値の条件による抽出：`filter()` {#filter}

`filter()`関数は第2引数以降で指定した条件に合致する行のみを抽出するためのverbです。以下のようにすると、変数`color`が`"blue"`である行のみが抽出されます。

```{r}
filter(df, color == "blue")
```

「等しい」という表現は、`==`となることに注意してください。変数`value`が1もしくは4の行のみ抽出する場合は

```{r}
filter(df, value %in% c(1, 4))
```

のようにします。条件部には以下のような、条件演算子を用いた条件式を記述します。

|演算子|機能|演算子|機能|
|:------|:------|:------|:------|
|`x > 1`|1より大きい|`x != 1`|1と等しくない|
|`x >= 1`|1以上|`x == 1`|1と等しい|
|`x < 1`|1より小さい|`x %in% c(1, 2)`|1か2のいずれか|
|`x <= 1`|1以下|

また、複数の条件を用いる場合は、以下のような論理演算子を用います。

|式|機能|
|:-----|:----------|
|`a | b`|条件aと条件bのいずれかを満たす（論理和）|
|`a & b`|条件aと条件bの両方を満たす（論理積）|
|`!a`|条件aを満たさない（否定）|
|`xor(a, b)`|条件aと条件bの排他的論理和|

`color`が`"blue"`で`value`が3未満の行のみを抽出するには以下のようにします。

```{r}
filter(df, color == "blue" & value <= 3)
```

### 指定した列の抽出：`select()` #{select}

`select()`関数は第2引数以降で指定した列を抽出するためのverbです。`df`から変数`color`のみ、もしくは`color`以外の変数を抽出するには次のようにします。

```{r}
select(df, color)
select(df, -color)
```

### 指定した列を昇順でソート：`arrange()` #{arrange}

`arrange()`は、第2引数以降で指定した列について、昇順でソートするためのverbです。`color`の列について、昇順でソートするには

```{r}
arrange(df, color)
```

とします。`color`の列は文字列であるため、アルファベット順に並びます。`value`の列を降順にソートするためには`desc()`関数を用いて

```{r}
arrange(df, desc(value))
```

とします。

### 新しい列の作成：`mutate()` {#mutate}

新しい列を作成して、他の列に対する演算結果等を格納する場合には、`mutate()`を用います。`df`の`value`列の各値を2倍した結果を新たに作成した`double`列に格納するには、以下のようにします。

```{r}
mutate(df, double = 2*value)
```

第2引数で定義した変数を、第3引数以降での演算に利用できます。

```{r}
mutate(df, double = 2*value, quadruple = 2*double)
```

### グループごとの要約：`group_by()`と`summarise()` {#summarise}

グループごとに平均値や中央値などの要約を計算したい場合には、`group_by()`と`summarise()`を組み合わせて用います。全体の要約を行う場合には、`summarise()`のみを用いることもあります。例えば、`df`の`value`の合計を求めるには以下のようにします。

```{r}
summarise(df, total = sum(value), .groups = "drop")
```

第3引数の`.groups = "drop"`は、要約後にグループ化の情報を残すかどうかの設定となります。特に必要が無ければ`"drop"`を指定しておくとよいでしょう。

`color`ごとに合計を求めるには、`group_by()`でグループ化を行ってから、`summarise()`で要約を行います。`group_by()`を実行することで、テーブルにグループ化された変数についての情報が付加されます。

```{r}
by_color <- group_by(df, color)
by_color
```

この出力は、`color`列に2つのグループが設定されていることを示しています。この結果に対して`summarise()`を適用すれば、グループごとの要約ができます。

```{r}
summarise(by_color, total = sum(value), .groups = "drop")
```

複数の列の値の組み合わせでグループ分けを行う場合には、それらの列名を`group_by()`の第2引数以降に並べます。

```{r}
by_date <- group_by(flights, year, month, day)
by_date
```

要約のための関数には以下のようなものがあります。

|関数|説明|
|:------|:------|
|`min(x)`, `max(x)`|`x`の最大値、最小値|
|`median(x)`|`x`の中央値|
|`n()`|グループごとの件数|
|`n_distinct()`|グループごとのユニークな行数|
|`sum(x)`, `mean(x)`|`x`の合計、平均値|
|`sum(x > 10)`|`x > 10`を満たす行数|
|`mean(x > 10)`|`x > 10`を満たす比率|
|`sd(x)`, `var(x)`|`x`の標準偏差、分散|

## パイプ {#pipe}

以下のように、複数のverbを続けて実行すると、可読性が悪くなります。どのような処理をしているのでしょうか。

```{r}
hourly_delay <- filter(
  summarise(
    group_by(
      filter(
        flights,
        !is.na(dep_delay)
      ),
      year, month, day, hour
    ),
    delay = mean(dep_delay),
    n = n(),
    .groups = "drop"
  ),
  n > 10
)
```

**magrittr**パッケージ（dplyrが入っていればインストールされている）で提供されている**パイプ演算子**を用いると、このような処理を簡潔に記述できる。一般に、ある関数`f()`をオブジェクト`x`に引数`y`を伴って適用する場合、

```
x %>% f(y)
```

と記述すれば

```
f(x, y)
```

を実行したことになります。パイプはいくつも続けて適用することができるため、上の処理は

```{r}
hourly_delay <- flights %>% 
  filter(!is.na(dep_delay)) %>% 
  group_by(year, month, day, hour) %>% 
  summarise(delay = mean(dep_delay),
            n = n(), .groups = "drop") %>% 
  filter(n > 10)
hourly_delay
```

のように記述できます。

