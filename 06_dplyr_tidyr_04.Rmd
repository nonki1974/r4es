
```{r echo=FALSE}
pacman::p_load(tidyverse)
```

## 縦長（long）データと横長（wide）データの相互変換 {#long_wide}

### `pivot_longer()`関数を用いたwideからlongへの変換

`table4a`や`table4b`は、列名が`1999`や`2000`というように「年」に関する変数の観測値となっています。また、テーブル内部の数値は、`table4a`の場合`cases`の観測値、`table4b`の場合は`population`の観測値というように、単一の変数の観測値が複数列にまたがっています。このような形のテーブルとなっているデータのことを**横長（wide型）データ**と呼びます。

```{r}
knitr::kable(table4a)
```

このデータを、`year`列に「年」の観測値（1999もしくは2000）、`cases`列に`cases`の観測値を格納する形式、すなわち**縦長（long型）データ**に変換するには、`pivot_longer()`関数を用います。

`pivot_longer()`関数の第1引数は**dplyr**のverbと同様にデータフレームとなります。また、関数を適用した結果もデータフレームになりますので、パイプ処理の中で利用できます。第2引数に、観測値が列名となっている列の一覧を**dplyr**の`select()`関数で変数を選択する場合と同様の形式（ただし、複数の変数の列挙は`c()`関数を使う）で与えます。また、それらに対する新たに設定する変数名を`names_to`引数に文字列として指定し、それらの値に対して新たに設定する変数名を`values_to`引数に文字列として指定します。`table4a`に対しては、例えば以下のようにします。

```{r}
table4a %>% 
  pivot_longer(-country, names_to = "year", values_to = "cases")
```

観測値が列名となっている列の一覧は、` c(`1999`,`2000`) `のような形式でもいいですが、ここでは`country`以外のすべての列ということで、`-country`としています。また、`names_to`と`values_to`は、新たに設定する変数名であり、`table4a`に含まれる列名ではありませんので、ダブルクォートをつけて文字列として指定する必要があります。

### `pivot_wider()`関数を用いたwideからlongへの変換

`table2`は1つの観測（各国の1年分の観測）が2行にまたがっています。これはtidydataの1行が1観測という原則を満たしておらず、tidydataではありません。これをtidydataにするためには、`count`列を広げて`key`列の値を変数名とした新たな列を作成する必要があります。

```{r}
knitr::kable(table2)
```

これは、前のセクションにおける`pivot_longer()`と逆の操作に相当し、long形式からwide形式への変換となります。これを行うのが`pivot_wider()`関数です。

`pivot_wider()`関数も`pivot_longer()`関数と同様にパイプ処理の中で利用できます。`names_from`引数に変数名を含む列（ここでは`key`）、`values_from`引数にそれらの変数名に対応した値が格納されている列（ここでは`count`）を指定します。これらは、データフレーム内の変数名ですので、ダブルクォートはつけません。`table2`に対しては例えば以下のようにします。

```{r}
table2 %>% 
  pivot_wider(names_from = key, values_from = value)
```

