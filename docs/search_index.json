[["index.html", "Rによるデータ解析入門 1 Rの基礎（データ構造とデータ型）", " Rによるデータ解析入門 Tomokazu FUJINO (@nonki1974) 1 Rの基礎（データ構造とデータ型） ここでは、データは数値や文字の集まりであると考えます。Rで標準的に利用できるデータの格納方法（データ構造）は以下の4つです。 ベクトル（vector） 配列・行列（array, matrix） リスト（list） データフレーム（data frame） 一方、個々のデータそのものの種類をデータ型と呼び、Rでは主に以下の3つを利用します。 数値型（numeric） 文字型（charater） 因子型（factor） 特に、因子型は他のプログラミング言語にはないデータ型で、統計解析環境であるRならではのデータ型となっています。 "],["vector.html", "1.1 データ構造（1）ベクトル", " 1.1 データ構造（1）ベクトル Rにおける最もシンプルなデータ構造がベクトルです。Rにおいては、単一の数値であっても、大きさ1のベクトルとして扱われます。例えば、以下のような演算を実行した結果の数値も大きさ1のベクトルです。結果に表示される[1]はそのすぐ右にある数値がベクトルの1番目の要素であることを示しています。 3+4 ## [1] 7 sqrt(9) ## [1] 3 sin(pi/6) ## [1] 0.5 多くの要素を持つベクトルの場合、例えば正規乱数を12個生成した結果のベクトルは以下のように表示されます。 rnorm(12) ## [1] 2.361913073 -0.001402661 0.083503925 -0.227898659 -1.477021256 ## [6] -0.533015025 -0.623019146 -2.217589226 1.288389062 -0.822329685 ## [11] -0.234357342 0.360880039 1.1.1 オブジェクトと変数 Rのコンソールにコマンドを入力すると、Rは何らかの結果をベクトルなどの形で出力してくれます。これらを総称してオブジェクトと呼びます。上のようなコマンドでは出力された結果のオブジェクトは再利用できませんが、変数に代入することで、再利用することができます。例えば、 x &lt;- rnorm(12) とすると、実行結果には何も表示されませんが、変数xの中に実行結果が格納されます。&lt;-（代入演算子と呼びます）は、左辺の変数に右辺の実行結果を代入しなさいという意味になります。つまり、xにrnorm(12)の結果のオブジェクトが格納されたということになります。xの中に何が入っているかを知りたい場合は、コンソールにxと入力します。 x ## [1] 0.79210717 1.25340374 -0.12097998 1.57571315 -1.67115716 -1.49636430 ## [7] 0.10384346 -0.16961622 1.15711398 -0.67783319 0.01813123 -1.17282992 変数名には、文字、数字、ピリオドなどの記号が利用できますが先頭に数字がつくものは使えません。また、大文字と小文字を区別しますので、注意しましょう。実際に分析するときは、分析者にとって分かりやすく、また複数の分析者で分析する場合は他の人が見てもある程度推測できるような変数名にするとよいです。 student_id &lt;- 1200 任意のベクトルを作成する場合は、c()関数1を用います。 x &lt;- c(3, 6, 10) x ## [1] 3 6 10 y &lt;- c(sin(pi/6), sqrt(9)) y ## [1] 0.5 3.0 1.1.2 便利なベクトル作成法 規則的に並んだ数値を要素とするベクトルを作成するには、いくつかの便利な方法があります。 # 1ずつ増加する数列 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 # 同じ数値の繰り返し rep(10, 5) ## [1] 10 10 10 10 10 # 増分を指定した数列（任意の公差をもつ等差数列） seq(1, 2, 0.1) ## [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 1.1.3 ベクトルの演算 ベクトル同士の演算は、2つのベクトルの大きさが同じ場合には要素同士の演算結果がベクトルとして返されます。 x &lt;- c(3, 6, 10) y &lt;- c(3, 2, 5) x + y ## [1] 6 8 15 x - y ## [1] 0 4 5 x * y ## [1] 9 12 50 x / y ## [1] 1 3 2 2つのベクトルの大きさが異なる場合には、小さい方のベクトルの要素が、大きい方と同じ大きさになるまで「リサイクル」されます。以下のコマンドはx^c(2, 2, 2)と同じであると理解しましょう。 x^2 ## [1] 9 36 100 以下のように、大きい方のベクトルの大きさが、小さい方の大きさの定数倍でない場合には警告が出力されます。 z &lt;- c(1, 2) x * z ## Warning in x * z: 長いオブジェクトの長さが短いオブジェクトの長さの倍数になってい ## ません ## [1] 3 12 10 1.1.4 ベクトルの要素の参照 ベクトルの要素を参照する場合は、[]を以下のように使います。 x[2] ## [1] 6 x[2:3] ## [1] 6 10 x[c(1, 3)] ## [1] 3 10 1.1.5 ベクトルに対する便利な関数 複数の処理をまとめたものを関数（function）といいます。関数にはRに元々組み込まれているものもありますし、自分で関数を作ることもできます。関数は 関数名() の形式で呼び出すことができ、()内にオブジェクトを記述することで、関数はそのオブジェクトに対して定められた処理を実行します。()内に記述するオブジェクトを引数（ひきすう）と呼びます。 ベクトルに対しては、以下のような関数がよく用いられます。 # ベクトルの大きさ（要素数）を出力する length(x) ## [1] 3 # 数値ベクトルの合計を出力する sum(x) ## [1] 19 # 数値ベクトルの平均を出力する mean(x) ## [1] 6.333333 # 数値ベクトルの標準偏差（standard deviation）を出力する sd(x) ## [1] 3.511885 cはcombineのcを意味している "],["datatype.html", "1.2 データ型", " 1.2 データ型 1.2.1 数値型と文字型 これまで扱ってきたベクトルに格納しているデータはすべて数値型（numeric）でした。Rでは文字列もデータとして扱うことができ、文字型（character）のデータと呼びます。文字型のデータはダブルクォート\"で囲むことによって表現します。 s &lt;- c(&quot;Kasumi&quot;, &quot;Nadeshiko&quot;, &quot;Kashii&quot;) s ## [1] &quot;Kasumi&quot; &quot;Nadeshiko&quot; &quot;Kashii&quot; ベクトルは、異なるデータ型を混在させることはできません。数値型と文字型が混在したベクトルを作成しようとすると、数値型が文字型に強制変換されます。 c(&quot;Happy&quot;, &quot;New&quot;, &quot;Year&quot;, 2021) ## [1] &quot;Happy&quot; &quot;New&quot; &quot;Year&quot; &quot;2021&quot; class()関数によってオブジェクトの型を確認することができます。 class(x) ## [1] &quot;numeric&quot; class(s) ## [1] &quot;character&quot; 1.2.2 因子型 統計データを扱うR言語独特のデータ型として、因子型（factor）があります。統計学においては、データをその性質から 名義尺度：分類コードやIDとして用いられる数値（血液型や性別など） 順序尺度：名義尺度に順序に関する情報が追加された数値（成績など） 間隔尺度：差の演算結果に意味がある数値（摂氏の気温など） 比例尺度：比の演算結果に意味がある数値（長さ重さなど、0が何もないを表すもの） の4種類に分類するという考え方が一般的です。名義尺度と順序尺度の値を持つ変数のことを質的変数と呼び、因子型は質的変数を扱うためのデータ型となっています。 # 数値型から因子型ベクトルを作成 hakata &lt;- c(0, 2, 3, 1, 3, 2, 1, 2) fhakata &lt;- factor(hakata, levels = 0:3) fhakata ## [1] 0 2 3 1 3 2 1 2 ## Levels: 0 1 2 3 as.numeric(fhakata) ## [1] 1 3 4 2 4 3 2 3 as.numeric(as.character(fhakata)) ## [1] 0 2 3 1 3 2 1 2 この例では、最初に数値型のベクトルを作成し、それをfactor()関数で因子型のベクトルに変換しています。factor()関数のlevels引数は、水準集合のベクトルを指定します。この場合、0という数値が1番目の水準に、1という数値が2番目の水準というように割り当てられることを意味します。 因子型のベクトルの場合、内容を表示するとLevelsの行のように水準集合が合わせて表示されるので、これでデータが因子型かどうかを見分けることができます。as.numeric()関数で因子型ベクトルを数値型ベクトルに変換すると、水準番号が出力されます。元のデータを出力する場合には、as.character()関数で一旦文字型ベクトルに変換してから、数値型ベクトルに変換します。 levels関数を使うと、水準集合を参照したり更新したりすることができます。 levels(fhakata) ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; levels(fhakata) &lt;- c(&quot;天ぷら&quot;, &quot;もつ鍋&quot;, &quot;ラーメン&quot;, &quot;ごまさば&quot;) fhakata ## [1] 天ぷら ラーメン ごまさば もつ鍋 ごまさば ラーメン もつ鍋 ラーメン ## Levels: 天ぷら もつ鍋 ラーメン ごまさば as.numeric(fhakata) ## [1] 1 3 4 2 4 3 2 3 質的変数のデータは、元々は文字列として記録されていることが多いかもしれません。文字型ベクトルをfactor()関数で因子型に変換すると、出現した要素全てが水準集合に含まれるようになります。 fhakata_char &lt;- c(&quot;天ぷら&quot;, &quot;もつ鍋&quot;, &quot;ラーメン&quot;, &quot;ごまさば&quot;, &quot;ラーメン&quot;) factor(fhakata_char) ## [1] 天ぷら もつ鍋 ラーメン ごまさば ラーメン ## Levels: ごまさば もつ鍋 ラーメン 天ぷら 1.2.3 論理型 TRUEとFALSEあるいはそれらの省略形としてTとFは、論理型（logical）と呼ばれるデータ型の値であり、それぞれ真（True）と偽（False）を表現するために用いられます2。 logical_sample &lt;- c(TRUE, FALSE, T, T, F, F) logical_sample ## [1] TRUE FALSE TRUE TRUE FALSE FALSE 1.2.4 欠損値の表現について 実際に統計データを扱う際には、何らかの理由で一部のデータが観測されなかったり、個人情報保護の目的で一部のデータが提供されていなかったりすることがあります。このようなデータを表現するために、Rでは欠損値を意味する値NAが用いられます。 x &lt;- c(2, 5, 10, NA, 3, 2) x ## [1] 2 5 10 NA 3 2 NAを含んだベクトルに対して演算や集計をした場合は次のようになります。 y &lt;- 1:6 x + y ## [1] 3 7 13 NA 8 8 sum(x) ## [1] NA mean(x) ## [1] NA sum()関数やmean()関数で欠損値を無視して計算したい場合には、引数でna.rm = TRUEを指定します。 sum(x, na.rm = TRUE) ## [1] 22 mean(x, na.rm = TRUE) ## [1] 4.4 因子型ベクトルを作成するとき、数値型のベクトルに水準集合に含まれない要素がある場合には、因子型ベクトルの中では欠損値として扱われます。 factor(c(2, 3, 5, 2), levels = 1:4) ## [1] 2 3 &lt;NA&gt; 2 ## Levels: 1 2 3 4 ダブルクォートがついていないので文字型ではないことに注意 "],["arrayandmatrix.html", "1.3 データ構造（2）配列と行列", " 1.3 データ構造（2）配列と行列 ベクトルに次元属性を与えることにより、配列として扱えるようになります。 x &lt;- 1:9 x ## [1] 1 2 3 4 5 6 7 8 9 # xを3x3の2次元配列（行列）として扱う dim(x) &lt;- c(3, 3) x ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 x3 &lt;- 1:27 # x3を3x3x3の3次元配列として扱う dim(x3) &lt;- c(3, 3, 3) x3 ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 10 13 16 ## [2,] 11 14 17 ## [3,] 12 15 18 ## ## , , 3 ## ## [,1] [,2] [,3] ## [1,] 19 22 25 ## [2,] 20 23 26 ## [3,] 21 24 27 dim()関数により次元属性が与えられ、引数には各次元の要素数を指定します。配列の各要素は、各次元の要素番号を指定しても、ベクトルとしての要素番号を指定しても参照できます。 x3[1, 2, 1] ## [1] 4 x3[4] ## [1] 4 特に2次元配列である行列を作成する場合には、matrix()関数を使うことができます。 matrix(1:15, ncol = 5, byrow = TRUE) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 ## [3,] 11 12 13 14 15 最初の引数でベクトルを指定しますncolは行列の列数、byrowは行方向にベクトルの要素を並べるかどうかをTRUEかFALSEで指定します（デフォルトはFALSE）。 "],["list.html", "1.4 データ構造（3）リスト", " 1.4 データ構造（3）リスト ベクトルは単一のデータ型しか保持できませんが、異なるデータ型のベクトルの集まりを1つのオブジェクトとして扱えるデータ構造をリストといいます。リストは、ベクトルだけでなく、別のリストも要素として持つことができます。 season &lt;- 2013 pacific &lt;- c(&quot;楽天&quot;, &quot;西武&quot;, &quot;ロッテ&quot;, &quot;ソフトバンク&quot;, &quot;オリックス&quot;, &quot;日本ハム&quot;) central &lt;- c(&quot;巨人&quot;, &quot;阪神&quot;, &quot;広島&quot;, &quot;中日&quot;, &quot;DeNA&quot;, &quot;ヤクルト&quot;) npb &lt;- list(pacific = pacific, central = central, season = season) npb ## $pacific ## [1] &quot;楽天&quot; &quot;西武&quot; &quot;ロッテ&quot; &quot;ソフトバンク&quot; &quot;オリックス&quot; ## [6] &quot;日本ハム&quot; ## ## $central ## [1] &quot;巨人&quot; &quot;阪神&quot; &quot;広島&quot; &quot;中日&quot; &quot;DeNA&quot; &quot;ヤクルト&quot; ## ## $season ## [1] 2013 リストを新たに作成するにはlist()関数を用います。引数は、要素の参照名 = オブジェクトをカンマ区切りで列挙します。リストのオブジェクト名の後に$要素の参照名をつけて実行すると、指定したリストの要素を直接参照できます。例えば、 npb$pacific ## [1] &quot;楽天&quot; &quot;西武&quot; &quot;ロッテ&quot; &quot;ソフトバンク&quot; &quot;オリックス&quot; ## [6] &quot;日本ハム&quot; また、npb[[1]]のようにすれば、要素番号でリストの要素を参照することもできます。 npb[[2]] ## [1] &quot;巨人&quot; &quot;阪神&quot; &quot;広島&quot; &quot;中日&quot; &quot;DeNA&quot; &quot;ヤクルト&quot; 以下のようにして、文字列として参照名を指定することもできますが、この場合の結果はリストとなります。 npb[&quot;central&quot;] ## $central ## [1] &quot;巨人&quot; &quot;阪神&quot; &quot;広島&quot; &quot;中日&quot; &quot;DeNA&quot; &quot;ヤクルト&quot; class(npb[&quot;central&quot;]) ## [1] &quot;list&quot; 統計計算などを行うRの関数の多くは、その結果をリストの形式で返します。リストの要素の参照名の一覧を見るにはnames()関数を用います。 names(npb) ## [1] &quot;pacific&quot; &quot;central&quot; &quot;season&quot; また、リストの構造を見たい場合は、str()関数を用います。 str(npb) ## List of 3 ## $ pacific: chr [1:6] &quot;楽天&quot; &quot;西武&quot; &quot;ロッテ&quot; &quot;ソフトバンク&quot; ... ## $ central: chr [1:6] &quot;巨人&quot; &quot;阪神&quot; &quot;広島&quot; &quot;中日&quot; ... ## $ season : num 2013 "],["dataframe.html", "1.5 データ構造（4）データフレーム", " 1.5 データ構造（4）データフレーム データフレームは、同じ長さの複数のベクトルを要素とするリストで、表形式のデータを扱うためのデータ構造です。行列と違い、各列のデータ型は異なっても構いません。データフレームの各行を個体、各列を変数と呼びます。データフレームを作成するには、data.frame()関数を用います。引数はlist()関数と同様です。 pacific_seiseki &lt;- data.frame(pacific = pacific, win = c(82, 74, 74, 73, 66, 64), lose = c(59, 66, 68, 69, 73, 78)) pacific_seiseki ## pacific win lose ## 1 楽天 82 59 ## 2 西武 74 66 ## 3 ロッテ 74 68 ## 4 ソフトバンク 73 69 ## 5 オリックス 66 73 ## 6 日本ハム 64 78 リストと同様に、データフレームの列を参照することができます。$で列名を指定すれば、その列のベクトルが返され、[\"列名\"]の形式で列名を指定すれば、1列のデータフレームとして結果が返されます。 pacific_seiseki$win ## [1] 82 74 74 73 66 64 pacific_seiseki[&quot;lose&quot;] ## lose ## 1 59 ## 2 66 ## 3 68 ## 4 69 ## 5 73 ## 6 78 リストと異なる点は、行列の要素と同様の参照が利用できることです。 # 要素の参照 pacific_seiseki[2, 3] ## [1] 66 # 行の参照 pacific_seiseki[4, ] ## pacific win lose ## 4 ソフトバンク 73 69 # 列の参照 pacific_seiseki[, 3] ## [1] 59 66 68 69 73 78 # 複数列の参照: 2列目から3列目 pacific_seiseki[, 2:3] ## win lose ## 1 82 59 ## 2 74 66 ## 3 74 68 ## 4 73 69 ## 5 66 73 ## 6 64 78 # 複数列の参照: 1列目と3列目 pacific_seiseki[, c(1, 3)] ## pacific lose ## 1 楽天 59 ## 2 西武 66 ## 3 ロッテ 68 ## 4 ソフトバンク 69 ## 5 オリックス 73 ## 6 日本ハム 78 データフレームの行数と列数は以下のようにして確認することができます。 # 行数 nrow(pacific_seiseki) ## [1] 6 # 列数 ncol(pacific_seiseki) ## [1] 3 # 同時に dim(pacific_seiseki) ## [1] 6 3 RStudioを利用している場合、Environment Paneにオブジェクトの一覧が表示されますが、その中でデータフレームのオブジェクトをクリックすると、スプレッドシートの形式で、データのプレビューが表示され、簡易的なデータの検索やソートができます。 1.5.1 外部データのデータフレームへのインポート これまでは、Rの基本的な説明のために、ベクトルやデータフレームのオブジェクトをコマンドで作成する方法を示してきましたが、実際の分析では既存の外部データをRにインポートすることが多いです。ここでは、CSVファイルをインポートする方法を紹介します。 fukuoka2015.csvは2015年の福岡県内市区町村の人口および世帯数のデータです。リンクをクリックするととブラウザでファイルの中身が表示されるので、作業ディレクトリ（プロジェクトフォルダの場所）に「data」というフォルダを作成して、その中に保存しておいてください（右クリック-&gt;「名前を付けて保存」）。CSVファイルをデータフレームとしてインポートするには、read.csv()関数を用います。 fukuoka2015 &lt;- read.csv(&quot;./data/fukuoka2015.csv&quot;, encoding = &quot;UTF-8&quot;) # データフレームの最初の6行を表示 head(fukuoka2015) ## area_code 地域 総面積 人口総数 昼間人口 世帯数 ## 1 40101 門司区 7367 99637 97946 43082 ## 2 40103 若松区 7131 82844 82591 33692 ## 3 40105 戸畑区 1661 59116 70519 27797 ## 4 40106 小倉北区 3923 181878 224589 91253 ## 5 40107 小倉南区 17174 212850 190913 88497 ## 6 40108 八幡東区 3626 68844 73391 31442 encoding引数に、読み込むファイルの文字コード（このファイルの場合UTF-8）を指定します。この引数を指定しない場合、システム標準の文字コード（Windowsの場合SHIFT-JIS、Macの場合UTF-8）で読み込まれます。ファイルの文字コードと読み込もうとする文字コードに相違がある場合、文字化けが発生します。UTF-8のファイルを読み込む場合、Macの環境では、encoding引数の指定は必要ありません。 特に引数を指定しない場合、csvファイルの中で、数値のみからなるの列は数値型、それ以外は文字型として読み込まれます。fukuoka2015の場合、area_codeはコード番号を表すので名義尺度ですが、数値型として読み込まれるので、必要に応じて因子型に変換します。また、地域は文字型として読み込まれるので、こちらも必要に応じて因子型に変換します（後述）。 str(fukuoka2015) ## &#39;data.frame&#39;: 68 obs. of 6 variables: ## $ area_code: int 40101 40103 40105 40106 40107 40108 40109 40131 40132 40133 ... ## $ 地域 : chr &quot;門司区&quot; &quot;若松区&quot; &quot;戸畑区&quot; &quot;小倉北区&quot; ... ## $ 総面積 : int 7367 7131 1661 3923 17174 3626 8313 6936 3163 1540 ... ## $ 人口総数 : int 99637 82844 59116 181878 212850 68844 256117 306015 228441 192688 ... ## $ 昼間人口 : int 97946 82591 70519 224589 190913 73391 243568 303352 381926 296992 ... ## $ 世帯数 : int 43082 33692 27797 91253 88497 31442 110562 141682 138832 116186 ... "],["datavis-summary.html", "2 データの簡単な要約と可視化 ", " 2 データの簡単な要約と可視化 "],["simple-summary.html", "2.1 データの簡単な要約", " 2.1 データの簡単な要約 前の章で読み込んだfukuoka2015を用いて、Rにおける基本的なデータの要約と可視化の方法を確認します。要約する際には、各列のデータ型が適切なものになっているか確認しましょう。前に述べたように、city_codeや地域の列は因子型に変換すべきでしょう。 fukuoka2015$area_code &lt;- factor(fukuoka2015$area_code) fukuoka2015$地域 &lt;- factor(fukuoka2015$地域) データフレームの各列についての要約を見たい場合は、summary()関数を使うと便利です。 summary(fukuoka2015) ## area_code 地域 総面積 人口総数 昼間人口 ## 40101 : 1 うきは市: 1 Min. : 572 Min. : 2174 Min. : 1946 ## 40103 : 1 みやこ町: 1 1st Qu.: 2165 1st Qu.: 18805 1st Qu.: 17175 ## 40105 : 1 みやま市: 1 Median : 4192 Median : 40270 Median : 37514 ## 40106 : 1 芦屋町 : 1 Mean : 6068 Mean : 70901 Mean : 71486 ## 40107 : 1 鞍手町 : 1 3rd Qu.: 7822 3rd Qu.: 87014 3rd Qu.: 83004 ## 40108 : 1 宇美町 : 1 Max. :24671 Max. :306015 Max. :381926 ## (Other):62 (Other) :62 ## 世帯数 ## Min. : 742 ## 1st Qu.: 7264 ## Median : 16508 ## Mean : 30830 ## 3rd Qu.: 35107 ## Max. :141682 ## データフレームを引数としてsummary()関数を実行すると、変数が数値型の場合、5数要約（最小値、最大値、第1四分位数、中央値、第3四分位数）と平均値が、因子型の場合、各水準ごとのデータの個数の集計値が出力されます。 ベクトルに対して利用した代表値（平均値や中央値）、ばらつきの指標（分散、標準偏差）などは、データフレームの列に対して適用できます。 mean(fukuoka2015$人口総数) ## [1] 70901.26 median(fukuoka2015$人口総数) ## [1] 40269.5 var(fukuoka2015$人口総数) ## [1] 5978006833 sd(fukuoka2015$人口総数) ## [1] 77317.57 数値型の変数の組に対しては、相関係数をcor()関数で計算することができます。 # 2つのベクトルを指定 cor(fukuoka2015$人口総数, fukuoka2015$昼間人口) ## [1] 0.9584306 # 複数列における変数の各組の相関係数を計算 cor(fukuoka2015[, 3:6]) ## 総面積 人口総数 昼間人口 世帯数 ## 総面積 1.0000000 0.2802705 0.2234106 0.2081516 ## 人口総数 0.2802705 1.0000000 0.9584306 0.9840105 ## 昼間人口 0.2234106 0.9584306 1.0000000 0.9876913 ## 世帯数 0.2081516 0.9840105 0.9876913 1.0000000 複数の変数の各組の相関係数を行列形式で表示したものを相関行列（Correlation Matrix）と呼びます。 "],["datavis-base.html", "2.2 データの簡単な可視化", " 2.2 データの簡単な可視化 まず、機械学習関連の情報やサンプルデータを提供している、UCI Machine Learning Repositoryから、ある卸売業者の顧客データをダウンロードしてみましょう。ページを開いたら「Data Folder」のリンクをたどると、CSVファイルへのリンクがあるので、これをダウンロードしてください。ダウンロードしたファイルは作業ディレクトリ（プロジェクトフォルダの場所）に作成した「data」フォルダに保存しておいてください。 CSVファイルをread.csv()関数でRにインポートします。 ws_customer &lt;- read.csv(&quot;./data/Wholesale customers data.csv&quot;) head(ws_customer) ## Channel Region Fresh Milk Grocery Frozen Detergents_Paper Delicassen ## 1 2 3 12669 9656 7561 214 2674 1338 ## 2 2 3 7057 9810 9568 1762 3293 1776 ## 3 2 3 6353 8808 7684 2405 3516 7844 ## 4 1 3 13265 1196 4221 6404 507 1788 ## 5 2 3 22615 5410 7198 3915 1777 5185 ## 6 2 3 9413 8259 5126 666 1795 1451 卸売業者の顧客データのページにおけるAttribute Informationの項目を見てみると、Channelは1がホテル、レストランやカフェ、2が小売の販売チャンネルを意味しています。また、Regionは1がリスボン、2がオポルト、3がその他の地域を表しているようです。これらは名義尺度の変数ですが、 str(ws_customer) ## &#39;data.frame&#39;: 440 obs. of 8 variables: ## $ Channel : int 2 2 2 1 2 2 2 2 1 2 ... ## $ Region : int 3 3 3 3 3 3 3 3 3 3 ... ## $ Fresh : int 12669 7057 6353 13265 22615 9413 12126 7579 5963 6006 ... ## $ Milk : int 9656 9810 8808 1196 5410 8259 3199 4956 3648 11093 ... ## $ Grocery : int 7561 9568 7684 4221 7198 5126 6975 9426 6192 18881 ... ## $ Frozen : int 214 1762 2405 6404 3915 666 480 1669 425 1159 ... ## $ Detergents_Paper: int 2674 3293 3516 507 1777 1795 3140 3321 1716 7425 ... ## $ Delicassen : int 1338 1776 7844 1788 5185 1451 545 2566 750 2098 ... で分かるように、数値型として取り込まれています。これを名義尺度として扱うために、因子型に変換しておきます。 ws_customer$Channel &lt;- factor(ws_customer$Channel, labels = c(&quot;Horeca&quot;, &quot;Retail&quot;)) ws_customer$Region &lt;- factor(ws_customer$Region, labels = c(&quot;Lisbon&quot;, &quot;Oporto&quot;, &quot;Other Region&quot;)) str(ws_customer) ## &#39;data.frame&#39;: 440 obs. of 8 variables: ## $ Channel : Factor w/ 2 levels &quot;Horeca&quot;,&quot;Retail&quot;: 2 2 2 1 2 2 2 2 1 2 ... ## $ Region : Factor w/ 3 levels &quot;Lisbon&quot;,&quot;Oporto&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... ## $ Fresh : int 12669 7057 6353 13265 22615 9413 12126 7579 5963 6006 ... ## $ Milk : int 9656 9810 8808 1196 5410 8259 3199 4956 3648 11093 ... ## $ Grocery : int 7561 9568 7684 4221 7198 5126 6975 9426 6192 18881 ... ## $ Frozen : int 214 1762 2405 6404 3915 666 480 1669 425 1159 ... ## $ Detergents_Paper: int 2674 3293 3516 507 1777 1795 3140 3321 1716 7425 ... ## $ Delicassen : int 1338 1776 7844 1788 5185 1451 545 2566 750 2098 ... summary()関数を適用すると以下のようになります。 summary(ws_customer) ## Channel Region Fresh Milk ## Horeca:298 Lisbon : 77 Min. : 3 Min. : 55 ## Retail:142 Oporto : 47 1st Qu.: 3128 1st Qu.: 1533 ## Other Region:316 Median : 8504 Median : 3627 ## Mean : 12000 Mean : 5796 ## 3rd Qu.: 16934 3rd Qu.: 7190 ## Max. :112151 Max. :73498 ## Grocery Frozen Detergents_Paper Delicassen ## Min. : 3 Min. : 25.0 Min. : 3.0 Min. : 3.0 ## 1st Qu.: 2153 1st Qu.: 742.2 1st Qu.: 256.8 1st Qu.: 408.2 ## Median : 4756 Median : 1526.0 Median : 816.5 Median : 965.5 ## Mean : 7951 Mean : 3071.9 Mean : 2881.5 Mean : 1524.9 ## 3rd Qu.:10656 3rd Qu.: 3554.2 3rd Qu.: 3922.0 3rd Qu.: 1820.2 ## Max. :92780 Max. :60869.0 Max. :40827.0 Max. :47943.0 2.2.1 棒グラフ 棒グラフは名義尺度と比例尺度の組からなるデータを可視化するツールですが、ここでは、Channel（名義尺度）ごとの度数（比例尺度）を棒グラフにしてみます。 channel_count &lt;- table(ws_customer$Channel) channel_count ## ## Horeca Retail ## 298 142 barplot(channel_count, ylim = c(0, 300), ylab = &quot;度数&quot;) 2.2.2 ヒストグラム 量的変数の値の分布をみるにはヒストグラムを用います。ヒストグラムは、量的変数の範囲をいくつかの区間に分割し、区間ごとに描かれた棒の面積がその区間に含まれる値の個数に比例するようにしたものです。例えば、Milkのヒストグラムを描くには次のようにhist()関数を用います。 hist(ws_customer$Milk, breaks = 20, xlim = c(0, 80000), ylim = c(0, 300), xlab = &quot;Milk&quot;, ylab = &quot;度数&quot;, main = &quot;&quot;) break引数は分割する区間の数を指定します。 2.2.3 箱ひげ図 量的変数の値の分布を質的変数の水準ごとに比較する場合には箱ひげ図を用います。例えば、ChannelごとにMilkの分布を比較したい場合には、次のようにboxplot()関数を用います。 boxplot(Milk ~ Channel, data = ws_customer, ylim = c(0, 80000)) 箱ひげ図は、箱の3本の水平線が下から順に第1四分位数、第2四分位数（中央値）、第3四分位数となっています。ひげ（箱の中央から延びる垂直な線）の下限と上限はそれぞれ、第1 四分位数-1.5\\(\\times\\)四分位範囲から第3分位点+1.5\\(\\times\\)四分位範囲内のデータの最小値および最大値となっています。その範囲外のデータは外れ値としてプロットされています。箱ひげ図は外れ値をチェックするツールとしても有効です。 2.2.4 散布図 2つの量的変数の値の組を座標平面上の点としてプロットしたものが散布図です。散布図を作成することで、2つの量的変数の関連性を見ることができます。例えば、Grocery（食料品）とDetergents_Paper（洗剤や紙製品）の散布図を描くには次のようにplot()関数を用います。 plot(ws_customer$Grocery, ws_customer$Detergents_Paper, xlab = &quot;Grocery&quot;, ylab = &quot;Detergents_Paper&quot;) 同じデータフレーム内の変数で散布図を描画する場合は、以下のように記述することもできます。 plot(Grocery, Detergents_Paper, data = ws_customer, xlab = &quot;Grocery&quot;, ylab = &quot;Detergents_Paper&quot;) 2.2.5 総称的関数 Rにおける関数のうち、総称関数（generic function）と呼ばれる関数は、引数の種類に応じて挙動が変わる性質を持ちます。例えば、plot()関数は、上のように2つのベクトルを引数として指定すれば、散布図を描画し、次のように、1つのベクトルを引数と指定すればインデックスプロットと呼ばれる、横軸にベクトルの要素番号、縦軸にベクトルの要素の値をプロットしたものが出力される。 plot(ws_customer$Grocery, ylab = &quot;Grocery&quot;) summary()関数も総称関数であり、データフレームを引数として指定した場合は、各変数の要約を出力しますが、分析結果のオブジェクトを引数として指定した場合には、分析結果の要約を出力します（これは後述）。 "],["dplyr-tidyr-01.html", "3 dplyr/tidyrを用いたデータの整理と変換(1) ", " 3 dplyr/tidyrを用いたデータの整理と変換(1) "],["package.html", "3.1 パッケージによる機能拡張", " 3.1 パッケージによる機能拡張 Rの特徴として、パッケージによって様々な機能を拡張できる点が挙げられます。パッケージのインストールには、install.packages()関数を用います。例えば、この後で利用するdplyrパッケージをインストールするには、以下のようにします。 install.packages(&quot;dplyr&quot;) パッケージのインストールは、Rを利用するPCで1度だけ実行しておけば十分です3。 パッケージで提供されている関数を利用する場合には、セッションごとにlibrary()関数を実行しておく必要があります。 library(dplyr) これを実行しない場合、関数をパッケージ名と共にdplyr::filter()のような形式で用いる必要があります。実行した場合は、単にfilter()とすれば利用できます。 ただし、dplyrパッケージは後述のtidyverseで合わせてインストールされますので、ここでは上記コマンドの実行は不要です。 定期的にアップデートは必要。Rのメジャーバージョン（例えば4.0.2の場合は“4”）が上がった場合は、インストールが必要） "],["tidyverse.html", "3.2 tidyverse", " 3.2 tidyverse tidyverseとは、tidy data（整然データ、整理データ）を軸としたデータサイエンスプロジェクトのためのパッケージ群です。tidyverseをインストールすると多くのパッケージがインストールされますが、主要なパッケージとしては以下のようなものになります。 dplyr : データの操作に関する一貫した文法を持つ関数を提供する ggplot2：Grammer of Graphics（グラフィックスの文法）に基づいて統計グラフを出力するための関数を提供する tidyr：tidy dataを得るために必要な関数を提供する readr：長方形のデータ（csv、tsvやfwfなど）を高速に読み込むための関数を提供する purr：Rにおける関数型プログラミング環境を提供する tibble：データフレームを拡張したクラスを提供する stringr：文字列処理を簡単に実行するための関数を提供する forcats：因子型を効率的に処理するための関数を提供する これらのパッケージが提供する関数は library(tidyverse) とすることで、一括して直接利用できるようになります。 "],["nycflights13.html", "3.3 nycflights13", " 3.3 nycflights13 ここでは、nycflights13パッケージで提供されているflightsデータを利用して各種機能の解説や演習を行っていきます。パッケージのインストールは以下のように行います。 install.packages(&quot;nycflights13&quot;) データを利用するには library(nycflights13) としておきます。 flightsにデータが格納されています。flightsデータは、データフレームを拡張したtibbleという形式となっていますが、ほとんどの場合データフレームと同じ扱い方で問題ありません4。データフレームの場合、以下のようにオブジェクトの中身を出力するとすべてが出力されますが、tibbleの場合、最初の10行のみと、コンソールに入る列数分の変数が表示され、データの下に残りの行数と変数の数と変数名と変数の型が表示されます。 flights ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # ... with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; flightsデータには、2013年にニューヨークの各空港を離陸したすべてのフライトに関する情報が記録されています。変数の一覧を表に示します。 列名 内容 列名 内容 year 年 tailnum 機体番号 month 月 flight 便名 day 日 origin 出発地 dep_time 離陸時刻 dest 到着地 dep_delay 離陸遅延時間[分] air_time 飛行時間[分] arr_time 到着時刻 distance 飛行距離 arr_delay 到着遅延時間[分] hour 離陸時刻[時] carrier 航空会社省略名 minute 離陸時刻[分] time_hour 出発予定時刻 そうでない場合も一部あります。 "],["onetable-verbs.html", "3.4 1つのテーブルに対するverb", " 3.4 1つのテーブルに対するverb dplyrパッケージはデータの操作に関する一貫した文法を持つ関数を提供しています。このパッケージにおいて、テーブル（データフレームやtibbleなど）に対して何らかの処理を行う関数のことをverbと呼びます。verbは以下のようなルールで用いられます。 最初の引数は処理対象となるテーブル 2番目以降の引数で、verbに関連するオプションを指定 帰ってくる値は常にテーブル verbの説明のために、以下のように簡単なデータフレームを作成しておきます。 df &lt;- data.frame( color = c(&quot;blue&quot;, &quot;black&quot;, &quot;blue&quot;, &quot;blue&quot;, &quot;black&quot;), value = 1:5 ) df ## color value ## 1 blue 1 ## 2 black 2 ## 3 blue 3 ## 4 blue 4 ## 5 black 5 3.4.1 値の条件による抽出：filter() filter()関数は第2引数以降で指定した条件に合致する行のみを抽出するためのverbです。以下のようにすると、変数colorが\"blue\"である行のみが抽出されます。 filter(df, color == &quot;blue&quot;) ## color value ## 1 blue 1 ## 2 blue 3 ## 3 blue 4 「等しい」という表現は、==となることに注意してください。変数valueが1もしくは4の行のみ抽出する場合は filter(df, value %in% c(1, 4)) ## color value ## 1 blue 1 ## 2 blue 4 のようにします。条件部には以下のような、条件演算子を用いた条件式を記述します。 演算子 機能 演算子 機能 x &gt; 1 1より大きい x != 1 1と等しくない x &gt;= 1 1以上 x == 1 1と等しい x &lt; 1 1より小さい x %in% c(1, 2) 1か2のいずれか x &lt;= 1 1以下 また、複数の条件を用いる場合は、以下のような論理演算子を用います。 式 機能 a | b 条件aと条件bのいずれかを満たす（論理和） a &amp; b 条件aと条件bの両方を満たす（論理積） !a 条件aを満たさない（否定） xor(a, b) 条件aと条件bの排他的論理和 colorが\"blue\"でvalueが3未満の行のみを抽出するには以下のようにします。 filter(df, color == &quot;blue&quot; &amp; value &lt;= 3) ## color value ## 1 blue 1 ## 2 blue 3 3.4.2 指定した列の抽出：select() #{select} select()関数は第2引数以降で指定した列を抽出するためのverbです。dfから変数colorのみ、もしくはcolor以外の変数を抽出するには次のようにします。 select(df, color) ## color ## 1 blue ## 2 black ## 3 blue ## 4 blue ## 5 black select(df, -color) ## value ## 1 1 ## 2 2 ## 3 3 ## 4 4 ## 5 5 3.4.3 指定した列を昇順でソート：arrange() #{arrange} arrange()は、第2引数以降で指定した列について、昇順でソートするためのverbです。colorの列について、昇順でソートするには arrange(df, color) ## color value ## 1 black 2 ## 2 black 5 ## 3 blue 1 ## 4 blue 3 ## 5 blue 4 とします。colorの列は文字列であるため、アルファベット順に並びます。valueの列を降順にソートするためにはdesc()関数を用いて arrange(df, desc(value)) ## color value ## 1 black 5 ## 2 blue 4 ## 3 blue 3 ## 4 black 2 ## 5 blue 1 とします。 3.4.4 新しい列の作成：mutate() 新しい列を作成して、他の列に対する演算結果等を格納する場合には、mutate()を用います。dfのvalue列の各値を2倍した結果を新たに作成したdouble列に格納するには、以下のようにします。 mutate(df, double = 2*value) ## color value double ## 1 blue 1 2 ## 2 black 2 4 ## 3 blue 3 6 ## 4 blue 4 8 ## 5 black 5 10 第2引数で定義した変数を、第3引数以降での演算に利用できます。 mutate(df, double = 2*value, quadruple = 2*double) ## color value double quadruple ## 1 blue 1 2 4 ## 2 black 2 4 8 ## 3 blue 3 6 12 ## 4 blue 4 8 16 ## 5 black 5 10 20 3.4.5 グループごとの要約：group_by()とsummarise() グループごとに平均値や中央値などの要約を計算したい場合には、group_by()とsummarise()を組み合わせて用います。全体の要約を行う場合には、summarise()のみを用いることもあります。例えば、dfのvalueの合計を求めるには以下のようにします。 summarise(df, total = sum(value), .groups = &quot;drop&quot;) ## total ## 1 15 第3引数の.groups = \"drop\"は、要約後にグループ化の情報を残すかどうかの設定となります。特に必要が無ければ\"drop\"を指定しておくとよいでしょう。 colorごとに合計を求めるには、group_by()でグループ化を行ってから、summarise()で要約を行います。group_by()を実行することで、テーブルにグループ化された変数についての情報が付加されます。 by_color &lt;- group_by(df, color) by_color ## # A tibble: 5 x 2 ## # Groups: color [2] ## color value ## &lt;chr&gt; &lt;int&gt; ## 1 blue 1 ## 2 black 2 ## 3 blue 3 ## 4 blue 4 ## 5 black 5 この出力は、color列に2つのグループが設定されていることを示しています。この結果に対してsummarise()を適用すれば、グループごとの要約ができます。 summarise(by_color, total = sum(value), .groups = &quot;drop&quot;) ## # A tibble: 2 x 2 ## color total ## &lt;chr&gt; &lt;int&gt; ## 1 black 7 ## 2 blue 8 複数の列の値の組み合わせでグループ分けを行う場合には、それらの列名をgroup_by()の第2引数以降に並べます。 by_date &lt;- group_by(flights, year, month, day) by_date ## # A tibble: 336,776 x 19 ## # Groups: year, month, day [365] ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # ... with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 要約のための関数には以下のようなものがあります。 関数 説明 min(x), max(x) xの最大値、最小値 median(x) xの中央値 n() グループごとの件数 n_distinct() グループごとのユニークな行数 sum(x), mean(x) xの合計、平均値 sum(x &gt; 10) x &gt; 10を満たす行数 mean(x &gt; 10) x &gt; 10を満たす比率 sd(x), var(x) xの標準偏差、分散 "],["pipe.html", "3.5 パイプ", " 3.5 パイプ 以下のように、複数のverbを続けて実行すると、可読性が悪くなります。どのような処理をしているのでしょうか。 hourly_delay &lt;- filter( summarise( group_by( filter( flights, !is.na(dep_delay) ), year, month, day, hour ), delay = mean(dep_delay), n = n(), .groups = &quot;drop&quot; ), n &gt; 10 ) magrittrパッケージ（dplyrが入っていればインストールされている）で提供されているパイプ演算子を用いると、このような処理を簡潔に記述できる。一般に、ある関数f()をオブジェクトxに引数yを伴って適用する場合、 x %&gt;% f(y) と記述すれば f(x, y) を実行したことになります。パイプはいくつも続けて適用することができるため、上の処理は hourly_delay &lt;- flights %&gt;% filter(!is.na(dep_delay)) %&gt;% group_by(year, month, day, hour) %&gt;% summarise(delay = mean(dep_delay), n = n(), .groups = &quot;drop&quot;) %&gt;% filter(n &gt; 10) hourly_delay ## # A tibble: 5,813 x 6 ## year month day hour delay n ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 6 2.16 51 ## 2 2013 1 1 7 3.51 49 ## 3 2013 1 1 8 0.448 58 ## 4 2013 1 1 9 5.34 56 ## 5 2013 1 1 10 0.333 39 ## 6 2013 1 1 11 3.19 37 ## 7 2013 1 1 12 5.75 56 ## 8 2013 1 1 13 20.4 54 ## 9 2013 1 1 14 17.2 48 ## 10 2013 1 1 15 7.77 66 ## # ... with 5,803 more rows のように記述できます。 "],["dplyr-tidyr-02.html", "4 dplyr/tidyrを用いたデータの整理と変換(2) ", " 4 dplyr/tidyrを用いたデータの整理と変換(2) "],["two-table-verbs.html", "4.1 2つのテーブルを結合するverb", " 4.1 2つのテーブルを結合するverb 2つのテーブルを、共通するIDなどを用いて結合するためのverbがあります。テーブル内で、ある変数の値を用いることで行を一意に特定できる変数のことをキー（Key）と呼びます。その中で、特に設計者が最も好ましいものとして選択したものを主キー（Primary Key）と呼びます。例えば、以下のようなテーブル「users」であればIDはキーとなります。 usersテーブル ID gcode A001 2 A002 1 A003 1 A004 2 A005 1 キーは単一の変数である必要はなく、複数変数の組み合わせによってキーとなることもあります。例えば、1日分の情報が1行となっているデータにおいて、年と月と日が異なる変数になっている場合には、3つの変数の組み合わせによってキーとなります。 上のテーブルで、gcodeは性別のコードを表していて、実際の性別の情報が以下のテーブル「gender」に格納されているとします。 genderテーブル gcode gender 1 女性 2 男性 このとき、usersテーブルにおけるgcodeは別のテーブルであるgenderテーブルのキーとなっており、usersテーブルの外部キーと呼ばれます。2つのテーブルの結合多くの場合、この外部キーを利用して行われます。 dplyrパッケージにおいて、2つのテーブルxとyを結合するためのverbは、 xxxxx_join(x, y) の形で用います。xxxxxの部分は以下のようなものがあります。 verb 結合方法 inner_join() xの外部キーの値とyのキーの値が一致するxとyの行を結合して出力 left_join() inner_join()で出力される行に加えて、xの外部キーの値がyのキー値のいずれにも一致しないxの行も出力される。これらの行に対応するyの変数の値はNAとなる。 right_join() inner_join()で出力される行に加えて、yの外部キーの値がxのキー値のいずれにも一致しないxの行も出力される。これらの行に対応するxの変数の値はNAとなる。 semi_join() xの外部キーの値とyのキーの値が一致するxの行を出力 anti_join() xの外部キーの値とyのキーの値が一致しないxの行を出力。semi_join()のxに関する補集合になる。 これらの動作を確認するために、以下のようにサンプルデータを作成します。 users &lt;- data.frame( id = paste0(&quot;A00&quot;, 1:6), gcode = c(2, 1, 1, 2, 1, 3) ) gender &lt;- data.frame( gcode = 1:2, gender = c(&quot;女性&quot;, &quot;男性&quot;) ) resp &lt;- data.frame( id = paste0(&quot;A00&quot;, c(1, 2, 4, 5)), Q1 = c(5, 3, 3, 2), Q2 = c(2, 3, 5, 5) ) answer &lt;- data.frame( acode = 1:5, answer = c(&quot;全く当てはまらない&quot;, &quot;当てはまらない&quot;, &quot;どちらでもない&quot;, &quot;当てはまる&quot;, &quot;とても当てはまる&quot;) ) inner_join()関数でusersのidとrespのidが一致するusersの行とrespの行を結合したものを出力します。 inner_join(users, resp) ## Joining, by = &quot;id&quot; ## id gcode Q1 Q2 ## 1 A001 2 5 2 ## 2 A002 1 3 3 ## 3 A004 2 3 5 ## 4 A005 1 2 5 left_join()関数でusersの全ての行に、respのidが一致するrespの行を結合したものを出力します。usersの行のうち、respのidと一致しない行については、respの列の値がNAとなります。 left_join(users, resp) ## Joining, by = &quot;id&quot; ## id gcode Q1 Q2 ## 1 A001 2 5 2 ## 2 A002 1 3 3 ## 3 A003 1 NA NA ## 4 A004 2 3 5 ## 5 A005 1 2 5 ## 6 A006 3 NA NA semi_join()関数は、inner_join()関数と同様にusersのidとrespのidが一致するusersの行を出力しますが、対応するrespの結合は行われません。 semi_join(users, resp) ## Joining, by = &quot;id&quot; ## id gcode ## 1 A001 2 ## 2 A002 1 ## 3 A004 2 ## 4 A005 1 anti_join()関数は、usersのidとrespのidが一致しないusersの行を出力します。 anti_join(users, resp) ## Joining, by = &quot;id&quot; ## id gcode ## 1 A003 1 ## 2 A006 3 これらの関数をパイプで繋ぐことで、以下のような出力を得ることができます。left_join()関数の引数byは、外部キーと参照先のキーの変数名が異なる場合に指定します。指定しなければ、同じ変数名の列が外部キーおよび参照先のキー列として処理されます。rename()関数は、列名を変更するためのものです。 left_join(users, gender) %&gt;% left_join(resp) %&gt;% left_join(answer, by = c(&quot;Q1&quot; = &quot;acode&quot;)) %&gt;% rename(q1a = answer) %&gt;% left_join(answer, by = c(&quot;Q2&quot; = &quot;acode&quot;)) %&gt;% rename(q2a = answer) %&gt;% select(id, gender, ends_with(&quot;a&quot;)) ## Joining, by = &quot;gcode&quot; ## Joining, by = &quot;id&quot; ## id gender q1a q2a ## 1 A001 男性 とても当てはまる 当てはまらない ## 2 A002 女性 どちらでもない どちらでもない ## 3 A003 女性 &lt;NA&gt; &lt;NA&gt; ## 4 A004 男性 どちらでもない とても当てはまる ## 5 A005 女性 当てはまらない とても当てはまる ## 6 A006 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; nycflights13パッケージには、flightsデータの他に、空港の情報が集約されたairportsデータが含まれています。例えば、空港ごとの遅延に関する要約を地図上に可視化したいような場合、空港の緯度経度の情報はairportsの方に含まれているため、これら両方のテーブルを結合したうえで分析する必要があります。 flights %&gt;% group_by(dest) %&gt;% summarise( arr_delay = mean(arr_delay, na.rm = TRUE), n = n(), .groups = &quot;drop&quot; ) %&gt;% left_join(airports, by = c(&quot;dest&quot; = &quot;faa&quot;)) ## # A tibble: 105 x 10 ## dest arr_delay n name lat lon alt tz dst tzone ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 ABQ 4.38 254 Albuquerque In~ 35.0 -107. 5355 -7 A America~ ## 2 ACK 4.85 265 Nantucket Mem 41.3 -70.1 48 -5 A America~ ## 3 ALB 14.4 439 Albany Intl 42.7 -73.8 285 -5 A America~ ## 4 ANC -2.5 8 Ted Stevens An~ 61.2 -150. 152 -9 A America~ ## 5 ATL 11.3 17215 Hartsfield Jac~ 33.6 -84.4 1026 -5 A America~ ## 6 AUS 6.02 2439 Austin Bergstr~ 30.2 -97.7 542 -6 A America~ ## 7 AVL 8.00 275 Asheville Regi~ 35.4 -82.5 2165 -5 A America~ ## 8 BDL 7.05 443 Bradley Intl 41.9 -72.7 173 -5 A America~ ## 9 BGR 8.03 375 Bangor Intl 44.8 -68.8 192 -5 A America~ ## 10 BHM 16.9 297 Birmingham Intl 33.6 -86.8 644 -6 A America~ ## # ... with 95 more rows また、weatherデータには、出発地（EWR：ニューアークリバティー国際空港）における時間ごとの温度、湿度、風速、降雨量などの情報が含まれています。これらの気象条件と飛行機の遅延に関する分析を行いたいような場合でも、テーブルの結合処理が必要となります。 flights %&gt;% group_by(year, month, day, hour) %&gt;% summarise( arr_delay = mean(arr_delay, na.rm = TRUE), n = n(), .groups = &quot;drop&quot; ) %&gt;% left_join(weather) ## Joining, by = c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;) ## # A tibble: 20,720 x 17 ## year month day hour arr_delay n origin temp dewp humid wind_dir ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 5 9 6 EWR 39.0 28.0 64.4 260 ## 2 2013 1 1 5 9 6 JFK 39.0 27.0 61.6 260 ## 3 2013 1 1 5 9 6 LGA 39.9 25.0 54.8 250 ## 4 2013 1 1 6 3.78 52 EWR 37.9 28.0 67.2 240 ## 5 2013 1 1 6 3.78 52 JFK 37.9 27.0 64.3 260 ## 6 2013 1 1 6 3.78 52 LGA 39.9 25.0 54.8 260 ## 7 2013 1 1 7 3.76 49 EWR 39.0 28.0 64.4 240 ## 8 2013 1 1 7 3.76 49 JFK 39.0 28.0 64.4 260 ## 9 2013 1 1 7 3.76 49 LGA 39.9 26.1 57.3 250 ## 10 2013 1 1 8 -2.40 58 EWR 39.9 28.0 62.2 250 ## # ... with 20,710 more rows, and 6 more variables: wind_speed &lt;dbl&gt;, ## # wind_gust &lt;dbl&gt;, precip &lt;dbl&gt;, pressure &lt;dbl&gt;, visib &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; "],["dplyr-tidyr-03.html", "5 dplyr/tidyrを用いたデータの整理と変換(3) ", " 5 dplyr/tidyrを用いたデータの整理と変換(3) "],["tidydata.html", "5.1 tidydataとは？", " 5.1 tidydataとは？ 以下の原則を満たすデータを、tidydataと呼びます。 各変数には専用の列がある 各観測には専用の行がある 各値は専用のセルにある データはさまざまな形で提供されますが、tidydataの形式に変換することで、分析や可視化がスムーズに行えるようになります。tidyverseに含まれるパッケージ群は、tidydataを前提とした関数を提供しています。その中でも、tidyでないデータをtidydataに変換する関数を提供するパッケージがtidyrパッケージです。 例えば、以下のようなデータはtidydataです。 table1 &lt;- tibble( country = c(&quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Brazil&quot;, &quot;Brazil&quot;, &quot;China&quot;, &quot;China&quot;), year = rep(c(1999L, 2000L), 3), cases = c(745L, 2666L, 37737L, 80488L, 212258L, 213766L), population = c(19987071L, 20595360L, 172006362L, 174504898L, 1272915272L, 1280428583L) ) country year cases population Afghanistan 1999 745 19987071 Afghanistan 2000 2666 20595360 Brazil 1999 37737 172006362 Brazil 2000 80488 174504898 China 1999 212258 1272915272 China 2000 213766 1280428583 以下のデータは、casesとpopulationの値がcountに混在しており、それぞれが専用の列をもたない形になっているため、tidydataではありません。 table2 &lt;- table1 %&gt;% pivot_longer(c(cases, population), names_to = &quot;key&quot;, values_to = &quot;value&quot;) %&gt;% arrange(country, year) country year key value Afghanistan 1999 cases 745 Afghanistan 1999 population 19987071 Afghanistan 2000 cases 2666 Afghanistan 2000 population 20595360 Brazil 1999 cases 37737 Brazil 1999 population 172006362 Brazil 2000 cases 80488 Brazil 2000 population 174504898 China 1999 cases 212258 China 1999 population 1272915272 China 2000 cases 213766 China 2000 population 1280428583 以下のデータは、rateの列におけるそれぞれのセルに複数の値が含まれているため、tidydataではありません。 table3 &lt;- table1 %&gt;% unite(rate, cases, population, sep = &quot;/&quot;) country year rate Afghanistan 1999 745/19987071 Afghanistan 2000 2666/20595360 Brazil 1999 37737/172006362 Brazil 2000 80488/174504898 China 1999 212258/1272915272 China 2000 213766/1280428583 以下のデータは、2つのテーブルにデータがまたがっているため、tidydataではありません。 table4a &lt;- table1 %&gt;% select(-population) %&gt;% pivot_wider(names_from = year, values_from = cases) country 1999 2000 Afghanistan 745 2666 Brazil 37737 80488 China 212258 213766 table4b &lt;- table1 %&gt;% select(-cases) %&gt;% pivot_wider(names_from = year, values_from = population) country 1999 2000 Afghanistan 19987071 20595360 Brazil 172006362 174504898 China 1272915272 1280428583 "],["long-wide.html", "5.2 縦長（long）データと横長（wide）データの相互変換", " 5.2 縦長（long）データと横長（wide）データの相互変換 5.2.1 pivot_longer()関数を用いたwideからlongへの変換 table4aやtable4bは、列名が1999や2000というように「年」に関する変数の観測値となっています。また、テーブル内部の数値は、table4aの場合casesの観測値、table4bの場合はpopulationの観測値というように、単一の変数の観測値が複数列にまたがっています。このような形のテーブルとなっているデータのことを横長（wide型）データと呼びます。 knitr::kable(table4a) country 1999 2000 Afghanistan 745 2666 Brazil 37737 80488 China 212258 213766 このデータを、year列に「年」の観測値（1999もしくは2000）、cases列にcasesの観測値を格納する形式、すなわち縦長（long型）データに変換するには、pivot_longer()関数を用います。 pivot_longer()関数の第1引数はdplyrのverbと同様にデータフレームとなります。また、関数を適用した結果もデータフレームになりますので、パイプ処理の中で利用できます。第2引数に、観測値が列名となっている列の一覧をdplyrのselect()関数で変数を選択する場合と同様の形式（ただし、複数の変数の列挙はc()関数を使う）で与えます。また、それらに対する新たに設定する変数名をnames_to引数に文字列として指定し、それらの値に対して新たに設定する変数名をvalues_to引数に文字列として指定します。table4aに対しては、例えば以下のようにします。 table4a %&gt;% pivot_longer(-country, names_to = &quot;year&quot;, values_to = &quot;cases&quot;) ## # A tibble: 6 x 3 ## country year cases ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 2000 2666 ## 3 Brazil 1999 37737 ## 4 Brazil 2000 80488 ## 5 China 1999 212258 ## 6 China 2000 213766 観測値が列名となっている列の一覧は、c(1999,2000)のような形式でもいいですが、ここではcountry以外のすべての列ということで、-countryとしています。また、names_toとvalues_toは、新たに設定する変数名であり、table4aに含まれる列名ではありませんので、ダブルクォートをつけて文字列として指定する必要があります。 5.2.2 pivot_wider()関数を用いたwideからlongへの変換 table2は1つの観測（各国の1年分の観測）が2行にまたがっています。これはtidydataの1行が1観測という原則を満たしておらず、tidydataではありません。これをtidydataにするためには、count列を広げてkey列の値を変数名とした新たな列を作成する必要があります。 knitr::kable(table2) country year key value Afghanistan 1999 cases 745 Afghanistan 1999 population 19987071 Afghanistan 2000 cases 2666 Afghanistan 2000 population 20595360 Brazil 1999 cases 37737 Brazil 1999 population 172006362 Brazil 2000 cases 80488 Brazil 2000 population 174504898 China 1999 cases 212258 China 1999 population 1272915272 China 2000 cases 213766 China 2000 population 1280428583 これは、前のセクションにおけるpivot_longer()と逆の操作に相当し、long形式からwide形式への変換となります。これを行うのがpivot_wider()関数です。 pivot_wider()関数もpivot_longer()関数と同様にパイプ処理の中で利用できます。names_from引数に変数名を含む列（ここではkey）、values_from引数にそれらの変数名に対応した値が格納されている列（ここではcount）を指定します。これらは、データフレーム内の変数名ですので、ダブルクォートはつけません。table2に対しては例えば以下のようにします。 table2 %&gt;% pivot_wider(names_from = key, values_from = value) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 "],["unite-and-separate.html", "5.3 列の分割と結合", " 5.3 列の分割と結合 table3はrateの列に複数の変数（populationとcases）の情報が文字列として格納されており、tidyではありません。このようにひとつの列に含まれている文字列を、複数の列に分割したい場合は、separate()関数を用います。separate()関数は、dplyrのverbと同様に、第1引数はデータフレームで、出力もデータフレームです。第1引数以外で必要な引数としては，分割元の変数を指定するcolと分割した後に設定する変数名のベクトルintoとなります。table3の場合、colにrate、intoにc(\"cases\", \"population\")を指定します。 table3 ## # A tibble: 6 x 3 ## country year rate ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 table3 %&gt;% separate(rate, c(&quot;cases&quot;, &quot;population&quot;)) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 これでもOKですが、分割された後の変数が文字列になっているので、数字のみの文字列であれば、convert引数をTRUEに設定すると、数値に変換してくれます。 table3 %&gt;% separate(rate, c(&quot;cases&quot;, &quot;population&quot;), convert = TRUE) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 また、区切り文字については、デフォルトでは数値以外の文字となっていますが、指定したい場合は、sep引数を指定します。（table3の場合は指定しなくてもOKです。） table3 %&gt;% separate(rate, c(&quot;cases&quot;, &quot;population&quot;), sep = &quot;/&quot;) separate()関数とは反対に、複数の変数をひとつの列に結合したい場合は、unite()関数を用います。ここでは、unite()関数の動作確認のために、table3のyearを先頭2桁のcenturyと後ろ2桁のyearに分割をしてから、再度結合することを考えます。sep引数に数値を与えると、その数値の桁数分で分割されます。 table5 &lt;- table3 %&gt;% separate(year, c(&quot;century&quot;, &quot;year&quot;, sep = 2)) ## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 6 rows [1, 2, 3, ## 4, 5, 6]. table5 ## # A tibble: 6 x 5 ## country century year `2` rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 &lt;NA&gt; &lt;NA&gt; 745/19987071 ## 2 Afghanistan 2000 &lt;NA&gt; &lt;NA&gt; 2666/20595360 ## 3 Brazil 1999 &lt;NA&gt; &lt;NA&gt; 37737/172006362 ## 4 Brazil 2000 &lt;NA&gt; &lt;NA&gt; 80488/174504898 ## 5 China 1999 &lt;NA&gt; &lt;NA&gt; 212258/1272915272 ## 6 China 2000 &lt;NA&gt; &lt;NA&gt; 213766/1280428583 centuryとyearの列をunite()関数で結合して、改めてyear列とします。unite()関数もdplyrのverbと同様に、第1引数はデータフレームで、出力もデータフレームです。第1引数以外で必要な引数としては，結合後の変数名colと、select()と同様に指定された結合対象の変数名となります。 table5 %&gt;% unite(col = new, century, year) ## # A tibble: 6 x 4 ## country new `2` rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999_NA &lt;NA&gt; 745/19987071 ## 2 Afghanistan 2000_NA &lt;NA&gt; 2666/20595360 ## 3 Brazil 1999_NA &lt;NA&gt; 37737/172006362 ## 4 Brazil 2000_NA &lt;NA&gt; 80488/174504898 ## 5 China 1999_NA &lt;NA&gt; 212258/1272915272 ## 6 China 2000_NA &lt;NA&gt; 213766/1280428583 このように、デフォルトではアンダースコア_によって結合されますが、結合文字を指定したい場合はsep変数を指定します（以下の例は空の文字列）。 table5 %&gt;% unite(col = new, century, year, sep = &quot;&quot;) ## # A tibble: 6 x 4 ## country new `2` rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999NA &lt;NA&gt; 745/19987071 ## 2 Afghanistan 2000NA &lt;NA&gt; 2666/20595360 ## 3 Brazil 1999NA &lt;NA&gt; 37737/172006362 ## 4 Brazil 2000NA &lt;NA&gt; 80488/174504898 ## 5 China 1999NA &lt;NA&gt; 212258/1272915272 ## 6 China 2000NA &lt;NA&gt; 213766/1280428583 "]]
