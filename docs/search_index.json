[
["index.html", "Rによるデータ解析入門 1 Rの基礎（データ構造とデータ型）", " Rによるデータ解析入門 Tomokazu FUJINO (@nonki1974) 1 Rの基礎（データ構造とデータ型） ここでは、データは数値や文字の集まりであると考えます。Rで標準的に利用できるデータの格納方法（データ構造）は以下の4つです。 ベクトル（vector） 配列・行列（array, matrix） リスト（list） データフレーム（data frame） 一方、個々のデータそのものの種類をデータ型と呼び、Rでは主に以下の3つを利用します。 数値型（numeric） 文字型（charater） 因子型（factor） 特に、因子型は他のプログラミング言語にはないデータ型で、統計解析環境であるRならではのデータ型となっています。 "],
["vector.html", "1.1 データ構造（1）ベクトル", " 1.1 データ構造（1）ベクトル Rにおける最もシンプルなデータ構造がベクトルです。Rにおいては、単一の数値であっても、大きさ1のベクトルとして扱われます。例えば、以下のような演算を実行した結果の数値も大きさ1のベクトルです。結果に表示される[1]はそのすぐ右にある数値がベクトルの1番目の要素であることを示しています。 3+4 ## [1] 7 sqrt(9) ## [1] 3 sin(pi/6) ## [1] 0.5 多くの要素を持つベクトルの場合、例えば正規乱数を12個生成した結果のベクトルは以下のように表示されます。 rnorm(12) ## [1] -0.5427483 0.2341528 -0.2236889 -0.2420070 1.6701658 -0.5032700 ## [7] 0.1244592 0.3367347 -0.9805708 -0.9125131 0.5868606 0.6084192 1.1.1 オブジェクトと変数 Rのコンソールにコマンドを入力すると、Rは何らかの結果をベクトルなどの形で出力してくれます。これらを総称してオブジェクトと呼びます。上のようなコマンドでは出力された結果のオブジェクトは再利用できませんが、変数に代入することで、再利用することができます。例えば、 x &lt;- rnorm(12) とすると、実行結果には何も表示されませんが、変数xの中に実行結果が格納されます。&lt;-（代入演算子と呼びます）は、左辺の変数に右辺の実行結果を代入しなさいという意味になります。つまり、xにrnorm(12)の結果のオブジェクトが格納されたということになります。xの中に何が入っているかを知りたい場合は、コンソールにxと入力します。 x ## [1] -1.5570789 0.2058010 0.5028496 -0.2104538 -0.5584586 -1.5288977 ## [7] 0.4790870 -0.8895862 0.0511404 -1.2294133 0.3278549 -0.3104764 変数名には、文字、数字、ピリオドなどの記号が利用できますが先頭に数字がつくものは使えません。また、大文字と小文字を区別しますので、注意しましょう。実際に分析するときは、分析者にとって分かりやすく、また複数の分析者で分析する場合は他の人が見てもある程度推測できるような変数名にするとよいです。 student_id &lt;- 1200 任意のベクトルを作成する場合は、c()関数1を用います。 x &lt;- c(3, 6, 10) x ## [1] 3 6 10 y &lt;- c(sin(pi/6), sqrt(9)) y ## [1] 0.5 3.0 1.1.2 便利なベクトル作成法 規則的に並んだ数値を要素とするベクトルを作成するには、いくつかの便利な方法があります。 # 1ずつ増加する数列 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 # 同じ数値の繰り返し rep(10, 5) ## [1] 10 10 10 10 10 # 増分を指定した数列（任意の公差をもつ等差数列） seq(1, 2, 0.1) ## [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 1.1.3 ベクトルの演算 ベクトル同士の演算は、2つのベクトルの大きさが同じ場合には要素同士の演算結果がベクトルとして返されます。 x &lt;- c(3, 6, 10) y &lt;- c(3, 2, 5) x + y ## [1] 6 8 15 x - y ## [1] 0 4 5 x * y ## [1] 9 12 50 x / y ## [1] 1 3 2 2つのベクトルの大きさが異なる場合には、小さい方のベクトルの要素が、大きい方と同じ大きさになるまで「リサイクル」されます。以下のコマンドはx^c(2, 2, 2)と同じであると理解しましょう。 x^2 ## [1] 9 36 100 以下のように、大きい方のベクトルの大きさが、小さい方の大きさの定数倍でない場合には警告が出力されます。 z &lt;- c(1, 2) x * z ## Warning in x * z: 長いオブジェクトの長さが短いオブジェクトの長さの倍数になってい ## ません ## [1] 3 12 10 1.1.4 ベクトルの要素の参照 ベクトルの要素を参照する場合は、[]を以下のように使います。 x[2] ## [1] 6 x[2:3] ## [1] 6 10 x[c(1, 3)] ## [1] 3 10 1.1.5 ベクトルに対する便利な関数 複数の処理をまとめたものを関数（function）といいます。関数にはRに元々組み込まれているものもありますし、自分で関数を作ることもできます。関数は 関数名() の形式で呼び出すことができ、()内にオブジェクトを記述することで、関数はそのオブジェクトに対して定められた処理を実行します。()内に記述するオブジェクトを引数（ひきすう）と呼びます。 ベクトルに対しては、以下のような関数がよく用いられます。 # ベクトルの大きさ（要素数）を出力する length(x) ## [1] 3 # 数値ベクトルの合計を出力する sum(x) ## [1] 19 # 数値ベクトルの平均を出力する mean(x) ## [1] 6.333333 # 数値ベクトルの標準偏差（standard deviation）を出力する sd(x) ## [1] 3.511885 cはcombineのcを意味している↩︎ "],
["datatype.html", "1.2 データ型", " 1.2 データ型 1.2.1 数値型と文字型 これまで扱ってきたベクトルに格納しているデータはすべて数値型（numeric）でした。Rでは文字列もデータとして扱うことができ、文字型（character）のデータと呼びます。文字型のデータはダブルクォート\"で囲むことによって表現します。 s &lt;- c(&quot;Kasumi&quot;, &quot;Nadeshiko&quot;, &quot;Kashii&quot;) s ## [1] &quot;Kasumi&quot; &quot;Nadeshiko&quot; &quot;Kashii&quot; ベクトルは、異なるデータ型を混在させることはできません。数値型と文字型が混在したベクトルを作成しようとすると、数値型が文字型に強制変換されます。 c(&quot;Happy&quot;, &quot;New&quot;, &quot;Year&quot;, 2021) ## [1] &quot;Happy&quot; &quot;New&quot; &quot;Year&quot; &quot;2021&quot; class()関数によってオブジェクトの型を確認することができます。 class(x) ## [1] &quot;numeric&quot; class(s) ## [1] &quot;character&quot; 1.2.2 因子型 統計データを扱うR言語独特のデータ型として、因子型（factor）があります。統計学においては、データをその性質から 名義尺度：分類コードやIDとして用いられる数値（血液型や性別など） 順序尺度：名義尺度に順序に関する情報が追加された数値（成績など） 間隔尺度：差の演算結果に意味がある数値（摂氏の気温など） 比例尺度：比の演算結果に意味がある数値（長さ重さなど、0が何もないを表すもの） の4種類に分類するという考え方が一般的です。名義尺度と順序尺度の値を持つ変数のことを質的変数と呼び、因子型は質的変数を扱うためのデータ型となっています。 # 数値型から因子型ベクトルを作成 hakata &lt;- c(0, 2, 3, 1, 3, 2, 1, 2) fhakata &lt;- factor(hakata, levels = 0:3) fhakata ## [1] 0 2 3 1 3 2 1 2 ## Levels: 0 1 2 3 as.numeric(fhakata) ## [1] 1 3 4 2 4 3 2 3 as.numeric(as.character(fhakata)) ## [1] 0 2 3 1 3 2 1 2 この例では、最初に数値型のベクトルを作成し、それをfactor()関数で因子型のベクトルに変換しています。factor()関数のlevels引数は、水準集合のベクトルを指定します。この場合、0という数値が1番目の水準に、1という数値が2番目の水準というように割り当てられることを意味します。 因子型のベクトルの場合、内容を表示するとLevelsの行のように水準集合が合わせて表示されるので、これでデータが因子型かどうかを見分けることができます。as.numeric()関数で因子型ベクトルを数値型ベクトルに変換すると、水準番号が出力されます。元のデータを出力する場合には、as.character()関数で一旦文字型ベクトルに変換してから、数値型ベクトルに変換します。 levels関数を使うと、水準集合を参照したり更新したりすることができます。 levels(fhakata) ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; levels(fhakata) &lt;- c(&quot;天ぷら&quot;, &quot;もつ鍋&quot;, &quot;ラーメン&quot;, &quot;ごまさば&quot;) fhakata ## [1] 天ぷら ラーメン ごまさば もつ鍋 ごまさば ラーメン もつ鍋 ラーメン ## Levels: 天ぷら もつ鍋 ラーメン ごまさば as.numeric(fhakata) ## [1] 1 3 4 2 4 3 2 3 質的変数のデータは、元々は文字列として記録されていることが多いかもしれません。文字型ベクトルをfactor()関数で因子型に変換すると、出現した要素全てが水準集合に含まれるようになります。 fhakata_char &lt;- c(&quot;天ぷら&quot;, &quot;もつ鍋&quot;, &quot;ラーメン&quot;, &quot;ごまさば&quot;, &quot;ラーメン&quot;) factor(fhakata_char) ## [1] 天ぷら もつ鍋 ラーメン ごまさば ラーメン ## Levels: ごまさば もつ鍋 ラーメン 天ぷら 1.2.3 論理型 TRUEとFALSEあるいはそれらの省略形としてTとFは、論理型（logical）と呼ばれるデータ型の値であり、それぞれ真（True）と偽（False）を表現するために用いられます2。 logical_sample &lt;- c(TRUE, FALSE, T, T, F, F) logical_sample ## [1] TRUE FALSE TRUE TRUE FALSE FALSE 1.2.4 欠損値の表現について 実際に統計データを扱う際には、何らかの理由で一部のデータが観測されなかったり、個人情報保護の目的で一部のデータが提供されていなかったりすることがあります。このようなデータを表現するために、Rでは欠損値を意味する値NAが用いられます。 x &lt;- c(2, 5, 10, NA, 3, 2) x ## [1] 2 5 10 NA 3 2 NAを含んだベクトルに対して演算や集計をした場合は次のようになります。 y &lt;- 1:6 x + y ## [1] 3 7 13 NA 8 8 sum(x) ## [1] NA mean(x) ## [1] NA sum()関数やmean()関数で欠損値を無視して計算したい場合には、引数でna.rm = TRUEを指定します。 sum(x, na.rm = TRUE) ## [1] 22 mean(x, na.rm = TRUE) ## [1] 4.4 因子型ベクトルを作成するとき、数値型のベクトルに水準集合に含まれない要素がある場合には、因子型ベクトルの中では欠損値として扱われます。 factor(c(2, 3, 5, 2), levels = 1:4) ## [1] 2 3 &lt;NA&gt; 2 ## Levels: 1 2 3 4 ダブルクォートがついていないので文字型ではないことに注意↩︎ "],
["arrayandmatrix.html", "1.3 データ構造（2）配列と行列", " 1.3 データ構造（2）配列と行列 ベクトルに次元属性を与えることにより、配列として扱えるようになります。 x &lt;- 1:9 x ## [1] 1 2 3 4 5 6 7 8 9 # xを3x3の2次元配列（行列）として扱う dim(x) &lt;- c(3, 3) x ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 x3 &lt;- 1:27 # x3を3x3x3の3次元配列として扱う dim(x3) &lt;- c(3, 3, 3) x3 ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 10 13 16 ## [2,] 11 14 17 ## [3,] 12 15 18 ## ## , , 3 ## ## [,1] [,2] [,3] ## [1,] 19 22 25 ## [2,] 20 23 26 ## [3,] 21 24 27 dim()関数により次元属性が与えられ、引数には各次元の要素数を指定します。配列の各要素は、各次元の要素番号を指定しても、ベクトルとしての要素番号を指定しても参照できます。 x3[1, 2, 1] ## [1] 4 x3[4] ## [1] 4 特に2次元配列である行列を作成する場合には、matrix()関数を使うことができます。 matrix(1:15, ncol = 5, byrow = TRUE) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 ## [3,] 11 12 13 14 15 最初の引数でベクトルを指定しますncolは行列の列数、byrowは行方向にベクトルの要素を並べるかどうかをTRUEかFALSEで指定します（デフォルトはFALSE）。 "]
]
