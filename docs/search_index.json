[["index.html", "Rによるデータ解析入門 1 Rの基礎（データ構造とデータ型）", " Rによるデータ解析入門 Tomokazu FUJINO (@nonki1974) 1 Rの基礎（データ構造とデータ型） ここでは、データは数値や文字の集まりであると考えます。Rで標準的に利用できるデータの格納方法（データ構造）は以下の4つです。 ベクトル（vector） 配列・行列（array, matrix） リスト（list） データフレーム（data frame） 基本はベクトルであり、それ以外のデータ構造はベクトルの拡張として定義されます（後述）。一方、個々のデータそのものの種類をデータ型と呼び、Rでは主に以下の3つを利用します。 論理型（logical） 整数型 (integer) 倍精度小数点型（実数型）（double） 文字型（character） また、厳密にはデータ型ではない（クラス：属性（後述）などを利用して拡張したデータ構造のようなもの）ですが、データ型のような感覚で利用できるものに因子型(factor)があります。これは、ベクトルに付加する情報（属性など）を使って定義されるもので、他のプログラミング言語にはない、統計解析環境であるRならではの概念になっています。 "],["vector.html", "1.1 データ構造（1）ベクトル", " 1.1 データ構造（1）ベクトル Rにおける最もシンプルなデータ構造がベクトルです。ベクトルは1つ以上のデータを格納できる入れ物だと考えてください。Rにおいては、単一の数値であっても、大きさ1のベクトルとして扱われます。例えば、以下のような演算を実行した結果の数値も大きさ1のベクトルです。結果に表示される[1]はそのすぐ右にある数値がベクトルの1番目の要素であることを示しています。 3+4 ## [1] 7 sqrt(9) ## [1] 3 sin(pi/6) ## [1] 0.5 多くの要素を持つベクトルの場合、例えば正規乱数を12個生成した結果のベクトルは以下のように表示されます。 rnorm(12) ## [1] 1.96047820 0.76681622 2.10019532 -0.75882043 -1.68978968 0.86209139 ## [7] 0.09478137 1.11941282 1.27309213 1.06817446 -1.47781417 -1.23055124 含まれるすべての要素が同じデータ型であるようなベクトルを特にアトミックベクトルと呼びます。アトミックベクトルに対してtypeof()関数を適用すると、データ型を確認することができます。 typeof(3) ## [1] &quot;double&quot; typeof(sqrt(9)) ## [1] &quot;double&quot; typeof(rnorm(12)) ## [1] &quot;double&quot; 1.1.1 オブジェクトと変数 Rのコンソールにコマンドを入力すると、Rは何らかの結果をベクトルなどの形で出力してくれます。これらを総称してオブジェクト（object)と呼びます。上のようなコマンドでは出力された結果のオブジェクトは再利用できませんが、変数(variable)に代入することで、再利用することができます。例えば、 x &lt;- rnorm(12) とすると、実行結果には何も表示されませんが、変数xの中に実行結果が格納されます。&lt;-（代入演算子と呼びます）は、左辺の変数に右辺の実行結果を代入しなさいという意味になります。つまり、xにrnorm(12)の結果のオブジェクトが格納されたということになります。xの中に何が入っているかを知りたい場合は、コンソールにxと入力します。 x ## [1] -0.45792716 1.07438789 2.18747655 -0.32152268 -0.09686016 -1.70237544 ## [7] -1.73217239 0.75952475 0.42987242 0.69523001 1.21567666 0.43265764 変数名には、文字、数字、ピリオドなどの記号が利用できますが先頭に数字がつくものは使えません。また、大文字と小文字を区別しますので、注意しましょう。実際に分析するときは、分析者にとって分かりやすく、また複数の分析者で分析する場合は他の人が見てもある程度推測できるような変数名にするとよいです。 student_id &lt;- 1200 任意のベクトルを作成する場合は、c()関数1を用います。 x &lt;- c(3, 6, 10) x ## [1] 3 6 10 y &lt;- c(sin(pi/6), sqrt(9)) y ## [1] 0.5 3.0 1.1.2 便利なベクトル作成法 規則的に並んだ数値を要素とするベクトルを作成するには、いくつかの便利な方法があります。 # 1ずつ増加する数列 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 # 同じ数値の繰り返し rep(10, 5) ## [1] 10 10 10 10 10 # 増分を指定した数列（任意の公差をもつ等差数列） seq(1, 2, 0.1) ## [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 1.1.3 ベクトルの演算 ベクトル同士の演算は、2つのベクトルの大きさが同じ場合には要素同士の演算結果がベクトルとして返されます。 x &lt;- c(3, 6, 10) y &lt;- c(3, 2, 5) x + y ## [1] 6 8 15 x - y ## [1] 0 4 5 x * y ## [1] 9 12 50 x / y ## [1] 1 3 2 2つのベクトルの大きさが異なる場合には、小さい方のベクトルの要素が、大きい方と同じ大きさになるまで「リサイクル」されます。以下のコマンドはx^c(2, 2, 2)と同じであると理解しましょう。 x^2 ## [1] 9 36 100 以下のように、大きい方のベクトルの大きさが、小さい方の大きさの定数倍でない場合には警告が出力されます。 z &lt;- c(1, 2) x * z ## Warning in x * z: 長いオブジェクトの長さが短いオブジェクトの長さの倍数になってい ## ません ## [1] 3 12 10 1.1.4 ベクトルの要素の参照 ベクトルの要素を参照する場合は、[]を以下のように使います。 x[2] ## [1] 6 x[2:3] ## [1] 6 10 x[c(1, 3)] ## [1] 3 10 1.1.5 ベクトルに対する便利な関数 複数の処理をまとめたものを関数（function）といいます。関数にはRに元々組み込まれているものもありますし、自分で関数を作ることもできます。関数は 関数名() の形式で呼び出すことができ、()内にオブジェクトを記述することで、関数はそのオブジェクトに対して定められた処理を実行します。()内に記述するオブジェクトを引数（ひきすう）と呼びます。 ベクトルに対しては、以下のような関数がよく用いられます。 # ベクトルの大きさ（要素数）を出力する length(x) ## [1] 3 # 数値ベクトルの合計を出力する sum(x) ## [1] 19 # 数値ベクトルの平均を出力する mean(x) ## [1] 6.333333 # 数値ベクトルの標準偏差（standard deviation）を出力する sd(x) ## [1] 3.511885 1.1.6 ベクトルの属性 すべてのオブジェクトには属性(attribute)を付与することができます。 a &lt;- c(3, 4, 10) attr(a, &quot;owner&quot;) &lt;- &quot;nonki1974&quot; attr(a, &quot;owner&quot;) ## [1] &quot;nonki1974&quot; cはcombineのcを意味している↩︎ "],["datatype.html", "1.2 データ型", " 1.2 データ型 1.2.1 数値型と文字型 これまで扱ってきたベクトルに格納しているデータはすべて整数型や実数型でした。Rでは文字列もデータとして扱うことができ、文字型（character）のデータと呼びます。文字型のデータはダブルクォート\"で囲むことによって表現します。 s &lt;- c(&quot;Kasumi&quot;, &quot;Nadeshiko&quot;, &quot;Kashii&quot;) s ## [1] &quot;Kasumi&quot; &quot;Nadeshiko&quot; &quot;Kashii&quot; アトミックベクトルは、単一のデータ型のみを格納します。数値型と文字型が混在したベクトルを作成しようとすると、数値型が文字型に強制変換されます。 c(&quot;Happy&quot;, &quot;New&quot;, &quot;Year&quot;, 2021) ## [1] &quot;Happy&quot; &quot;New&quot; &quot;Year&quot; &quot;2021&quot; typeof()関数によってオブジェクトの型を確認してみます。 typeof(x) ## [1] &quot;double&quot; typeof(s) ## [1] &quot;character&quot; 1.2.2 因子型 統計データを扱うR言語独特のクラス（データ構造を拡張したようなもの）として、因子型（factor）があります。統計学においては、データをその性質から 名義尺度：分類コードやIDとして用いられる数値（血液型や性別など） 順序尺度：名義尺度に順序に関する情報が追加された数値（成績など） 間隔尺度：差の演算結果に意味がある数値（摂氏の気温など） 比例尺度：比の演算結果に意味がある数値（長さ重さなど、0が何もないを表すもの） の4種類に分類するという考え方が一般的です。名義尺度と順序尺度の値を持つ変数のことを質的変数と呼び、因子型は質的変数を扱うためのデータ型となっています。 # 数値型から因子型ベクトルを作成 hakata &lt;- c(0, 2, 3, 1, 3, 2, 1, 2) fhakata &lt;- factor(hakata, levels = 0:3) fhakata ## [1] 0 2 3 1 3 2 1 2 ## Levels: 0 1 2 3 この例では、最初に数値型のベクトルを作成し、それをfactor()関数で因子型のベクトルに変換しています。factor()関数のlevels引数は、水準集合のベクトルを指定します。この場合、0という数値が1番目の水準に、1という数値が2番目の水準というように割り当てられることを意味します。 因子型のベクトルの場合、内容を表示するとLevelsの行のように水準集合が合わせて表示されるので、これでデータが因子型かどうかを見分けることができます。 attributes(fhakata) ## $levels ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; ## ## $class ## [1] &quot;factor&quot; as.numeric(fhakata) ## [1] 1 3 4 2 4 3 2 3 as.numeric(as.character(fhakata)) ## [1] 0 2 3 1 3 2 1 2 attributes()関数を使うと、引数で指定されたオブジェクトの属性一覧を表示することができます。fhakataはlevelsとclassの2つの属性を持っていることが確認できます。因子型の実体は、水準番号（1,2,3・・・）をベクトルの要素として持ち、水準番号に対応した水準集合を属性として持っているようなオブジェクトになります。 as.numeric()関数で因子型ベクトルを数値型ベクトルに変換すると、水準番号が出力されます。元のデータを出力する場合には、as.character()関数で一旦文字型ベクトルに変換してから、数値型ベクトルに変換します。 levels関数を使うと、水準集合を参照したり更新したりすることができます。 levels(fhakata) ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; levels(fhakata) &lt;- c(&quot;天ぷら&quot;, &quot;もつ鍋&quot;, &quot;ラーメン&quot;, &quot;ごまさば&quot;) fhakata ## [1] 天ぷら ラーメン ごまさば もつ鍋 ごまさば ラーメン もつ鍋 ラーメン ## Levels: 天ぷら もつ鍋 ラーメン ごまさば as.numeric(fhakata) ## [1] 1 3 4 2 4 3 2 3 質的変数のデータは、元々は文字列として記録されていることが多いかもしれません。文字型ベクトルをfactor()関数で因子型に変換すると、出現した要素全てが水準集合に含まれるようになります。 fhakata_char &lt;- c(&quot;天ぷら&quot;, &quot;もつ鍋&quot;, &quot;ラーメン&quot;, &quot;ごまさば&quot;, &quot;ラーメン&quot;) factor(fhakata_char) ## [1] 天ぷら もつ鍋 ラーメン ごまさば ラーメン ## Levels: ごまさば もつ鍋 ラーメン 天ぷら 上で述べたように、因子型の実体は水準番号なので、typeof()関数でfhakataのデータ型を確認するとintegerとなります。一方、class()関数でfhakataのクラスを確認するとfactorとなります。 typeof(fhakata) ## [1] &quot;integer&quot; class(fhakata) ## [1] &quot;factor&quot; 1.2.3 論理型 TRUEとFALSEあるいはそれらの省略形としてTとFは、論理型（logical）と呼ばれるデータ型の値であり、それぞれ真（True）と偽（False）を表現するために用いられます2。 logical_sample &lt;- c(TRUE, FALSE, T, T, F, F) logical_sample ## [1] TRUE FALSE TRUE TRUE FALSE FALSE 1.2.4 欠損値の表現について 実際に統計データを扱う際には、何らかの理由で一部のデータが観測されなかったり、個人情報保護の目的で一部のデータが提供されていなかったりすることがあります。このようなデータを表現するために、Rでは欠損値を意味する値NAが用いられます。 x &lt;- c(2, 5, 10, NA, 3, 2) x ## [1] 2 5 10 NA 3 2 NAを含んだベクトルに対して演算や集計をした場合は次のようになります。 y &lt;- 1:6 x + y ## [1] 3 7 13 NA 8 8 sum(x) ## [1] NA mean(x) ## [1] NA sum()関数やmean()関数で欠損値を無視して計算したい場合には、引数でna.rm = TRUEを指定します。 sum(x, na.rm = TRUE) ## [1] 22 mean(x, na.rm = TRUE) ## [1] 4.4 因子型ベクトルを作成するとき、数値型のベクトルに水準集合に含まれない要素がある場合には、因子型ベクトルの中では欠損値として扱われます。 factor(c(2, 3, 5, 2), levels = 1:4) ## [1] 2 3 &lt;NA&gt; 2 ## Levels: 1 2 3 4 ダブルクォートがついていないので文字型ではないことに注意↩︎ "],["arrayandmatrix.html", "1.3 データ構造（2）配列と行列", " 1.3 データ構造（2）配列と行列 ベクトルに次元属性を与えることにより、配列として扱えるようになります。 x &lt;- 1:9 x ## [1] 1 2 3 4 5 6 7 8 9 # xを3x3の2次元配列（行列）として扱う dim(x) &lt;- c(3, 3) attributes(x) ## $dim ## [1] 3 3 x ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 x3 &lt;- 1:27 # x3を3x3x3の3次元配列として扱う dim(x3) &lt;- c(3, 3, 3) x3 ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 10 13 16 ## [2,] 11 14 17 ## [3,] 12 15 18 ## ## , , 3 ## ## [,1] [,2] [,3] ## [1,] 19 22 25 ## [2,] 20 23 26 ## [3,] 21 24 27 dim()関数により次元属性が与えられ、引数には各次元の要素数を指定します。配列の各要素は、各次元の要素番号を指定しても、ベクトルとしての要素番号を指定しても参照できます。 x3[1, 2, 1] ## [1] 4 x3[4] ## [1] 4 特に2次元配列である行列を作成する場合には、matrix()関数を使うことができます。 matrix(1:15, ncol = 5, byrow = TRUE) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 ## [3,] 11 12 13 14 15 最初の引数でベクトルを指定しますncolは行列の列数、byrowは行方向にベクトルの要素を並べるかどうかをTRUEかFALSEで指定します（デフォルトはFALSE）。 "],["list.html", "1.4 データ構造（3）リスト", " 1.4 データ構造（3）リスト ベクトルは単一のデータ型しか保持できませんが、異なるデータ型のベクトルの集まりを1つのオブジェクトとして扱えるデータ構造をリストといいます。リストは、ベクトルだけでなく、別のリストも要素として持つことができます。 season &lt;- 2013 pacific &lt;- c(&quot;楽天&quot;, &quot;西武&quot;, &quot;ロッテ&quot;, &quot;ソフトバンク&quot;, &quot;オリックス&quot;, &quot;日本ハム&quot;) central &lt;- c(&quot;巨人&quot;, &quot;阪神&quot;, &quot;広島&quot;, &quot;中日&quot;, &quot;DeNA&quot;, &quot;ヤクルト&quot;) npb &lt;- list(pacific = pacific, central = central, season = season) npb ## $pacific ## [1] &quot;楽天&quot; &quot;西武&quot; &quot;ロッテ&quot; &quot;ソフトバンク&quot; &quot;オリックス&quot; ## [6] &quot;日本ハム&quot; ## ## $central ## [1] &quot;巨人&quot; &quot;阪神&quot; &quot;広島&quot; &quot;中日&quot; &quot;DeNA&quot; &quot;ヤクルト&quot; ## ## $season ## [1] 2013 リストを新たに作成するにはlist()関数を用います。引数は、要素の参照名 = オブジェクトをカンマ区切りで列挙します。リストのオブジェクト名の後に$要素の参照名をつけて実行すると、指定したリストの要素を直接参照できます。例えば、 npb$pacific ## [1] &quot;楽天&quot; &quot;西武&quot; &quot;ロッテ&quot; &quot;ソフトバンク&quot; &quot;オリックス&quot; ## [6] &quot;日本ハム&quot; また、npb[[1]]のようにすれば、要素番号でリストの要素を参照することもできます。 npb[[2]] ## [1] &quot;巨人&quot; &quot;阪神&quot; &quot;広島&quot; &quot;中日&quot; &quot;DeNA&quot; &quot;ヤクルト&quot; 以下のようにして、文字列として参照名を指定することもできますが、この場合の結果はリストとなります。 npb[&quot;central&quot;] ## $central ## [1] &quot;巨人&quot; &quot;阪神&quot; &quot;広島&quot; &quot;中日&quot; &quot;DeNA&quot; &quot;ヤクルト&quot; typeof(npb[&quot;central&quot;]) ## [1] &quot;list&quot; 統計計算などを行うRの関数の多くは、その結果をリストの形式で返します。リストの要素の参照名の一覧を見るにはnames()関数を用います。 names(npb) ## [1] &quot;pacific&quot; &quot;central&quot; &quot;season&quot; また、リストの構造を見たい場合は、str()関数を用います。 str(npb) ## List of 3 ## $ pacific: chr [1:6] &quot;楽天&quot; &quot;西武&quot; &quot;ロッテ&quot; &quot;ソフトバンク&quot; ... ## $ central: chr [1:6] &quot;巨人&quot; &quot;阪神&quot; &quot;広島&quot; &quot;中日&quot; ... ## $ season : num 2013 "],["dataframe.html", "1.5 データ構造（4）データフレーム", " 1.5 データ構造（4）データフレーム データフレームは、同じ長さの複数のベクトルを要素とするリストで、表形式のデータを扱うためのデータ構造です。行列と違い、各列のデータ型は異なっても構いません。データフレームの各行を個体、各列を変数と呼びます。データフレームを作成するには、data.frame()関数を用います。引数はlist()関数と同様です。 pacific_seiseki &lt;- data.frame(pacific = pacific, win = c(82, 74, 74, 73, 66, 64), lose = c(59, 66, 68, 69, 73, 78)) pacific_seiseki ## pacific win lose ## 1 楽天 82 59 ## 2 西武 74 66 ## 3 ロッテ 74 68 ## 4 ソフトバンク 73 69 ## 5 オリックス 66 73 ## 6 日本ハム 64 78 リストと同様に、データフレームの列を参照することができます。$で列名を指定すれば、その列のベクトルが返され、[\"列名\"]の形式で列名を指定すれば、1列のデータフレームとして結果が返されます。 pacific_seiseki$win ## [1] 82 74 74 73 66 64 pacific_seiseki[&quot;lose&quot;] ## lose ## 1 59 ## 2 66 ## 3 68 ## 4 69 ## 5 73 ## 6 78 リストと異なる点は、行列の要素と同様の参照が利用できることです。 # 要素の参照 pacific_seiseki[2, 3] ## [1] 66 # 行の参照 pacific_seiseki[4, ] ## pacific win lose ## 4 ソフトバンク 73 69 # 列の参照 pacific_seiseki[, 3] ## [1] 59 66 68 69 73 78 # 複数列の参照: 2列目から3列目 pacific_seiseki[, 2:3] ## win lose ## 1 82 59 ## 2 74 66 ## 3 74 68 ## 4 73 69 ## 5 66 73 ## 6 64 78 # 複数列の参照: 1列目と3列目 pacific_seiseki[, c(1, 3)] ## pacific lose ## 1 楽天 59 ## 2 西武 66 ## 3 ロッテ 68 ## 4 ソフトバンク 69 ## 5 オリックス 73 ## 6 日本ハム 78 データフレームの行数と列数は以下のようにして確認することができます。 # 行数 nrow(pacific_seiseki) ## [1] 6 # 列数 ncol(pacific_seiseki) ## [1] 3 # 同時に dim(pacific_seiseki) ## [1] 6 3 RStudioを利用している場合、Environment Paneにオブジェクトの一覧が表示されますが、その中でデータフレームのオブジェクトをクリックすると、スプレッドシートの形式で、データのプレビューが表示され、簡易的なデータの検索やソートができます。 1.5.1 外部データのデータフレームへのインポート これまでは、Rの基本的な説明のために、ベクトルやデータフレームのオブジェクトをコマンドで作成する方法を示してきましたが、実際の分析では既存の外部データをRにインポートすることが多いです。ここでは、CSVファイルをインポートする方法を紹介します。 fukuoka2015.csvは2015年の福岡県内市区町村の人口および世帯数のデータです。リンクをクリックするととブラウザでファイルの中身が表示されるので、作業ディレクトリ（プロジェクトフォルダの場所）に「data」というフォルダを作成して、その中に保存しておいてください（右クリック-&gt;「名前を付けて保存」）。CSVファイルをデータフレームとしてインポートするには、read.csv()関数を用います。 fukuoka2015 &lt;- read.csv(&quot;./data/fukuoka2015.csv&quot;, encoding = &quot;UTF-8&quot;) # データフレームの最初の6行を表示 head(fukuoka2015) ## area_code 地域 総面積 人口総数 昼間人口 世帯数 ## 1 40101 門司区 7367 99637 97946 43082 ## 2 40103 若松区 7131 82844 82591 33692 ## 3 40105 戸畑区 1661 59116 70519 27797 ## 4 40106 小倉北区 3923 181878 224589 91253 ## 5 40107 小倉南区 17174 212850 190913 88497 ## 6 40108 八幡東区 3626 68844 73391 31442 encoding引数に、読み込むファイルの文字コード（このファイルの場合UTF-8）を指定します。この引数を指定しない場合、システム標準の文字コード（Windowsの場合SHIFT-JIS、Macの場合UTF-8）で読み込まれます。ファイルの文字コードと読み込もうとする文字コードに相違がある場合、文字化けが発生します。UTF-8のファイルを読み込む場合、Macの環境では、encoding引数の指定は必要ありません。 特に引数を指定しない場合、csvファイルの中で、数値のみからなるの列は数値型、それ以外は文字型として読み込まれます。fukuoka2015の場合、area_codeはコード番号を表すので名義尺度ですが、数値型として読み込まれるので、必要に応じて因子型に変換します。また、地域は文字型として読み込まれるので、こちらも必要に応じて因子型に変換します（後述）。 str(fukuoka2015) ## &#39;data.frame&#39;: 68 obs. of 6 variables: ## $ area_code: int 40101 40103 40105 40106 40107 40108 40109 40131 40132 40133 ... ## $ 地域 : chr &quot;門司区&quot; &quot;若松区&quot; &quot;戸畑区&quot; &quot;小倉北区&quot; ... ## $ 総面積 : int 7367 7131 1661 3923 17174 3626 8313 6936 3163 1540 ... ## $ 人口総数 : int 99637 82844 59116 181878 212850 68844 256117 306015 228441 192688 ... ## $ 昼間人口 : int 97946 82591 70519 224589 190913 73391 243568 303352 381926 296992 ... ## $ 世帯数 : int 43082 33692 27797 91253 88497 31442 110562 141682 138832 116186 ... "],["datavis-summary.html", "2 データの簡単な要約と可視化 ", " 2 データの簡単な要約と可視化 "],["simple-summary.html", "2.1 データの簡単な要約", " 2.1 データの簡単な要約 前の章で読み込んだfukuoka2015を用いて、Rにおける基本的なデータの要約と可視化の方法を確認します。要約する際には、各列のデータ型が適切なものになっているか確認しましょう。前に述べたように、city_codeや地域の列は因子型に変換すべきでしょう。 fukuoka2015$area_code &lt;- factor(fukuoka2015$area_code) fukuoka2015$地域 &lt;- factor(fukuoka2015$地域) データフレームの各列についての要約を見たい場合は、summary()関数を使うと便利です。 summary(fukuoka2015) ## area_code 地域 総面積 人口総数 昼間人口 ## 40101 : 1 うきは市: 1 Min. : 572 Min. : 2174 Min. : 1946 ## 40103 : 1 みやこ町: 1 1st Qu.: 2165 1st Qu.: 18805 1st Qu.: 17175 ## 40105 : 1 みやま市: 1 Median : 4192 Median : 40270 Median : 37514 ## 40106 : 1 芦屋町 : 1 Mean : 6068 Mean : 70901 Mean : 71486 ## 40107 : 1 鞍手町 : 1 3rd Qu.: 7822 3rd Qu.: 87014 3rd Qu.: 83004 ## 40108 : 1 宇美町 : 1 Max. :24671 Max. :306015 Max. :381926 ## (Other):62 (Other) :62 ## 世帯数 ## Min. : 742 ## 1st Qu.: 7264 ## Median : 16508 ## Mean : 30830 ## 3rd Qu.: 35107 ## Max. :141682 ## データフレームを引数としてsummary()関数を実行すると、変数が数値型の場合、5数要約（最小値、最大値、第1四分位数、中央値、第3四分位数）と平均値が、因子型の場合、各水準ごとのデータの個数の集計値が出力されます。 ベクトルに対して利用した代表値（平均値や中央値）、ばらつきの指標（分散、標準偏差）などは、データフレームの列に対して適用できます。 mean(fukuoka2015$人口総数) ## [1] 70901.26 median(fukuoka2015$人口総数) ## [1] 40269.5 var(fukuoka2015$人口総数) ## [1] 5978006833 sd(fukuoka2015$人口総数) ## [1] 77317.57 数値型の変数の組に対しては、相関係数をcor()関数で計算することができます。 # 2つのベクトルを指定 cor(fukuoka2015$人口総数, fukuoka2015$昼間人口) ## [1] 0.9584306 # 複数列における変数の各組の相関係数を計算 cor(fukuoka2015[, 3:6]) ## 総面積 人口総数 昼間人口 世帯数 ## 総面積 1.0000000 0.2802705 0.2234106 0.2081516 ## 人口総数 0.2802705 1.0000000 0.9584306 0.9840105 ## 昼間人口 0.2234106 0.9584306 1.0000000 0.9876913 ## 世帯数 0.2081516 0.9840105 0.9876913 1.0000000 複数の変数の各組の相関係数を行列形式で表示したものを相関行列（Correlation Matrix）と呼びます。 "],["datavis-base.html", "2.2 データの簡単な可視化", " 2.2 データの簡単な可視化 まず、機械学習関連の情報やサンプルデータを提供している、UCI Machine Learning Repositoryから、ある卸売業者の顧客データをダウンロードしてみましょう。ページを開いたら「Data Folder」のリンクをたどると、CSVファイルへのリンクがあるので、これをダウンロードしてください。ダウンロードしたファイルは作業ディレクトリ（プロジェクトフォルダの場所）に作成した「data」フォルダに保存しておいてください。 CSVファイルをread.csv()関数でRにインポートします。 ws_customer &lt;- read.csv(&quot;./data/Wholesale customers data.csv&quot;) head(ws_customer) ## Channel Region Fresh Milk Grocery Frozen Detergents_Paper Delicassen ## 1 2 3 12669 9656 7561 214 2674 1338 ## 2 2 3 7057 9810 9568 1762 3293 1776 ## 3 2 3 6353 8808 7684 2405 3516 7844 ## 4 1 3 13265 1196 4221 6404 507 1788 ## 5 2 3 22615 5410 7198 3915 1777 5185 ## 6 2 3 9413 8259 5126 666 1795 1451 卸売業者の顧客データのページにおけるAttribute Informationの項目を見てみると、Channelは1がホテル、レストランやカフェ、2が小売の販売チャンネルを意味しています。また、Regionは1がリスボン、2がオポルト、3がその他の地域を表しているようです。これらは名義尺度の変数ですが、 str(ws_customer) ## &#39;data.frame&#39;: 440 obs. of 8 variables: ## $ Channel : int 2 2 2 1 2 2 2 2 1 2 ... ## $ Region : int 3 3 3 3 3 3 3 3 3 3 ... ## $ Fresh : int 12669 7057 6353 13265 22615 9413 12126 7579 5963 6006 ... ## $ Milk : int 9656 9810 8808 1196 5410 8259 3199 4956 3648 11093 ... ## $ Grocery : int 7561 9568 7684 4221 7198 5126 6975 9426 6192 18881 ... ## $ Frozen : int 214 1762 2405 6404 3915 666 480 1669 425 1159 ... ## $ Detergents_Paper: int 2674 3293 3516 507 1777 1795 3140 3321 1716 7425 ... ## $ Delicassen : int 1338 1776 7844 1788 5185 1451 545 2566 750 2098 ... で分かるように、数値型として取り込まれています。これを名義尺度として扱うために、因子型に変換しておきます。 ws_customer$Channel &lt;- factor(ws_customer$Channel, labels = c(&quot;Horeca&quot;, &quot;Retail&quot;)) ws_customer$Region &lt;- factor(ws_customer$Region, labels = c(&quot;Lisbon&quot;, &quot;Oporto&quot;, &quot;Other Region&quot;)) str(ws_customer) ## &#39;data.frame&#39;: 440 obs. of 8 variables: ## $ Channel : Factor w/ 2 levels &quot;Horeca&quot;,&quot;Retail&quot;: 2 2 2 1 2 2 2 2 1 2 ... ## $ Region : Factor w/ 3 levels &quot;Lisbon&quot;,&quot;Oporto&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... ## $ Fresh : int 12669 7057 6353 13265 22615 9413 12126 7579 5963 6006 ... ## $ Milk : int 9656 9810 8808 1196 5410 8259 3199 4956 3648 11093 ... ## $ Grocery : int 7561 9568 7684 4221 7198 5126 6975 9426 6192 18881 ... ## $ Frozen : int 214 1762 2405 6404 3915 666 480 1669 425 1159 ... ## $ Detergents_Paper: int 2674 3293 3516 507 1777 1795 3140 3321 1716 7425 ... ## $ Delicassen : int 1338 1776 7844 1788 5185 1451 545 2566 750 2098 ... summary()関数を適用すると以下のようになります。 summary(ws_customer) ## Channel Region Fresh Milk ## Horeca:298 Lisbon : 77 Min. : 3 Min. : 55 ## Retail:142 Oporto : 47 1st Qu.: 3128 1st Qu.: 1533 ## Other Region:316 Median : 8504 Median : 3627 ## Mean : 12000 Mean : 5796 ## 3rd Qu.: 16934 3rd Qu.: 7190 ## Max. :112151 Max. :73498 ## Grocery Frozen Detergents_Paper Delicassen ## Min. : 3 Min. : 25.0 Min. : 3.0 Min. : 3.0 ## 1st Qu.: 2153 1st Qu.: 742.2 1st Qu.: 256.8 1st Qu.: 408.2 ## Median : 4756 Median : 1526.0 Median : 816.5 Median : 965.5 ## Mean : 7951 Mean : 3071.9 Mean : 2881.5 Mean : 1524.9 ## 3rd Qu.:10656 3rd Qu.: 3554.2 3rd Qu.: 3922.0 3rd Qu.: 1820.2 ## Max. :92780 Max. :60869.0 Max. :40827.0 Max. :47943.0 2.2.1 棒グラフ 棒グラフは名義尺度と比例尺度の組からなるデータを可視化するツールですが、ここでは、Channel（名義尺度）ごとの度数（比例尺度）を棒グラフにしてみます。 channel_count &lt;- table(ws_customer$Channel) channel_count ## ## Horeca Retail ## 298 142 barplot(channel_count, ylim = c(0, 300), ylab = &quot;度数&quot;) 2.2.2 ヒストグラム 量的変数の値の分布をみるにはヒストグラムを用います。ヒストグラムは、量的変数の範囲をいくつかの区間に分割し、区間ごとに描かれた棒の面積がその区間に含まれる値の個数に比例するようにしたものです。例えば、Milkのヒストグラムを描くには次のようにhist()関数を用います。 hist(ws_customer$Milk, breaks = 20, xlim = c(0, 80000), ylim = c(0, 300), xlab = &quot;Milk&quot;, ylab = &quot;度数&quot;, main = &quot;&quot;) break引数は分割する区間の数を指定します。 2.2.3 箱ひげ図 量的変数の値の分布を質的変数の水準ごとに比較する場合には箱ひげ図を用います。例えば、ChannelごとにMilkの分布を比較したい場合には、次のようにboxplot()関数を用います。 boxplot(Milk ~ Channel, data = ws_customer, ylim = c(0, 80000)) 箱ひげ図は、箱の3本の水平線が下から順に第1四分位数、第2四分位数（中央値）、第3四分位数となっています。ひげ（箱の中央から延びる垂直な線）の下限と上限はそれぞれ、第1 四分位数-1.5\\(\\times\\)四分位範囲から第3分位点+1.5\\(\\times\\)四分位範囲内のデータの最小値および最大値となっています。その範囲外のデータは外れ値としてプロットされています。箱ひげ図は外れ値をチェックするツールとしても有効です。 2.2.4 散布図 2つの量的変数の値の組を座標平面上の点としてプロットしたものが散布図です。散布図を作成することで、2つの量的変数の関連性を見ることができます。例えば、Grocery（食料品）とDetergents_Paper（洗剤や紙製品）の散布図を描くには次のようにplot()関数を用います。 plot(ws_customer$Grocery, ws_customer$Detergents_Paper, xlab = &quot;Grocery&quot;, ylab = &quot;Detergents_Paper&quot;) 同じデータフレーム内の変数で散布図を描画する場合は、以下のように記述することもできます。 plot(Grocery, Detergents_Paper, data = ws_customer, xlab = &quot;Grocery&quot;, ylab = &quot;Detergents_Paper&quot;) 2.2.5 総称的関数 Rにおける関数のうち、総称関数（generic function）と呼ばれる関数は、引数の種類に応じて挙動が変わる性質を持ちます。例えば、plot()関数は、上のように2つのベクトルを引数として指定すれば、散布図を描画し、次のように、1つのベクトルを引数と指定すればインデックスプロットと呼ばれる、横軸にベクトルの要素番号、縦軸にベクトルの要素の値をプロットしたものが出力される。 plot(ws_customer$Grocery, ylab = &quot;Grocery&quot;) summary()関数も総称関数であり、データフレームを引数として指定した場合は、各変数の要約を出力しますが、分析結果のオブジェクトを引数として指定した場合には、分析結果の要約を出力します（これは後述）。 "],["dplyr-tidyr-01.html", "3 dplyr/tidyrを用いたデータの整理と変換(1) ", " 3 dplyr/tidyrを用いたデータの整理と変換(1) "],["package.html", "3.1 パッケージによる機能拡張", " 3.1 パッケージによる機能拡張 Rの特徴として、パッケージによって様々な機能を拡張できる点が挙げられます。パッケージのインストールには、install.packages()関数を用います。例えば、この後で利用するdplyrパッケージをインストールするには、以下のようにします。 install.packages(&quot;dplyr&quot;) パッケージのインストールは、Rを利用するPCで1度だけ実行しておけば十分です3。 パッケージで提供されている関数を利用する場合には、セッションごとにlibrary()関数を実行しておく必要があります。 library(dplyr) これを実行しない場合、関数をパッケージ名と共にdplyr::filter()のような形式で用いる必要があります。実行した場合は、単にfilter()とすれば利用できます。 ただし、dplyrパッケージは後述のtidyverseで合わせてインストールされますので、ここでは上記コマンドの実行は不要です。 定期的にアップデートは必要。Rのメジャーバージョン（例えば4.0.2の場合は“4”）が上がった場合は、インストールが必要）↩︎ "],["tidyverse.html", "3.2 tidyverse", " 3.2 tidyverse tidyverseとは、tidy data（整然データ、整理データ）を軸としたデータサイエンスプロジェクトのためのパッケージ群です。tidyverseをインストールすると多くのパッケージがインストールされますが、主要なパッケージとしては以下のようなものになります。 dplyr : データの操作に関する一貫した文法を持つ関数を提供する ggplot2：Grammer of Graphics（グラフィックスの文法）に基づいて統計グラフを出力するための関数を提供する tidyr：tidy dataを得るために必要な関数を提供する readr：長方形のデータ（csv、tsvやfwfなど）を高速に読み込むための関数を提供する purr：Rにおける関数型プログラミング環境を提供する tibble：データフレームを拡張したクラスを提供する stringr：文字列処理を簡単に実行するための関数を提供する forcats：因子型を効率的に処理するための関数を提供する これらのパッケージが提供する関数は library(tidyverse) とすることで、一括して直接利用できるようになります。 "],["nycflights13.html", "3.3 nycflights13", " 3.3 nycflights13 ここでは、nycflights13パッケージで提供されているflightsデータを利用して各種機能の解説や演習を行っていきます。パッケージのインストールは以下のように行います。 install.packages(&quot;nycflights13&quot;) データを利用するには library(nycflights13) としておきます。 flightsにデータが格納されています。flightsデータは、データフレームを拡張したtibbleという形式となっていますが、ほとんどの場合データフレームと同じ扱い方で問題ありません4。データフレームの場合、以下のようにオブジェクトの中身を出力するとすべてが出力されますが、tibbleの場合、最初の10行のみと、コンソールに入る列数分の変数が表示され、データの下に残りの行数と変数の数と変数名と変数の型が表示されます。 flights ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # ... with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; flightsデータには、2013年にニューヨークの各空港を離陸したすべてのフライトに関する情報が記録されています。変数の一覧を表に示します。 列名 内容 列名 内容 year 年 tailnum 機体番号 month 月 flight 便名 day 日 origin 出発地 dep_time 離陸時刻 dest 到着地 dep_delay 離陸遅延時間[分] air_time 飛行時間[分] arr_time 到着時刻 distance 飛行距離 arr_delay 到着遅延時間[分] hour 離陸時刻[時] carrier 航空会社省略名 minute 離陸時刻[分] time_hour 出発予定時刻 そうでない場合も一部あります。↩︎ "],["onetable-verbs.html", "3.4 1つのテーブルに対するverb", " 3.4 1つのテーブルに対するverb dplyrパッケージはデータの操作に関する一貫した文法を持つ関数を提供しています。このパッケージにおいて、テーブル（データフレームやtibbleなど）に対して何らかの処理を行う関数のことをverbと呼びます。verbは以下のようなルールで用いられます。 最初の引数は処理対象となるテーブル 2番目以降の引数で、verbに関連するオプションを指定 帰ってくる値は常にテーブル verbの説明のために、以下のように簡単なデータフレームを作成しておきます。 df &lt;- data.frame( color = c(&quot;blue&quot;, &quot;black&quot;, &quot;blue&quot;, &quot;blue&quot;, &quot;black&quot;), value = 1:5 ) df ## color value ## 1 blue 1 ## 2 black 2 ## 3 blue 3 ## 4 blue 4 ## 5 black 5 3.4.1 値の条件による抽出：filter() filter()関数は第2引数以降で指定した条件に合致する行のみを抽出するためのverbです。以下のようにすると、変数colorが\"blue\"である行のみが抽出されます。 filter(df, color == &quot;blue&quot;) ## color value ## 1 blue 1 ## 2 blue 3 ## 3 blue 4 「等しい」という表現は、==となることに注意してください。変数valueが1もしくは4の行のみ抽出する場合は filter(df, value %in% c(1, 4)) ## color value ## 1 blue 1 ## 2 blue 4 のようにします。条件部には以下のような、条件演算子を用いた条件式を記述します。 演算子 機能 演算子 機能 x &gt; 1 1より大きい x != 1 1と等しくない x &gt;= 1 1以上 x == 1 1と等しい x &lt; 1 1より小さい x %in% c(1, 2) 1か2のいずれか x &lt;= 1 1以下 また、複数の条件を用いる場合は、以下のような論理演算子を用います。 式 機能 a | b 条件aと条件bのいずれかを満たす（論理和） a &amp; b 条件aと条件bの両方を満たす（論理積） !a 条件aを満たさない（否定） xor(a, b) 条件aと条件bの排他的論理和 colorが\"blue\"でvalueが3未満の行のみを抽出するには以下のようにします。 filter(df, color == &quot;blue&quot; &amp; value &lt;= 3) ## color value ## 1 blue 1 ## 2 blue 3 3.4.2 指定した列の抽出：select() #{select} select()関数は第2引数以降で指定した列を抽出するためのverbです。dfから変数colorのみ、もしくはcolor以外の変数を抽出するには次のようにします。 select(df, color) ## color ## 1 blue ## 2 black ## 3 blue ## 4 blue ## 5 black select(df, -color) ## value ## 1 1 ## 2 2 ## 3 3 ## 4 4 ## 5 5 3.4.3 指定した列を昇順でソート：arrange() #{arrange} arrange()は、第2引数以降で指定した列について、昇順でソートするためのverbです。colorの列について、昇順でソートするには arrange(df, color) ## color value ## 1 black 2 ## 2 black 5 ## 3 blue 1 ## 4 blue 3 ## 5 blue 4 とします。colorの列は文字列であるため、アルファベット順に並びます。valueの列を降順にソートするためにはdesc()関数を用いて arrange(df, desc(value)) ## color value ## 1 black 5 ## 2 blue 4 ## 3 blue 3 ## 4 black 2 ## 5 blue 1 とします。 3.4.4 新しい列の作成：mutate() 新しい列を作成して、他の列に対する演算結果等を格納する場合には、mutate()を用います。dfのvalue列の各値を2倍した結果を新たに作成したdouble列に格納するには、以下のようにします。 mutate(df, double = 2*value) ## color value double ## 1 blue 1 2 ## 2 black 2 4 ## 3 blue 3 6 ## 4 blue 4 8 ## 5 black 5 10 第2引数で定義した変数を、第3引数以降での演算に利用できます。 mutate(df, double = 2*value, quadruple = 2*double) ## color value double quadruple ## 1 blue 1 2 4 ## 2 black 2 4 8 ## 3 blue 3 6 12 ## 4 blue 4 8 16 ## 5 black 5 10 20 3.4.5 グループごとの要約：group_by()とsummarise() グループごとに平均値や中央値などの要約を計算したい場合には、group_by()とsummarise()を組み合わせて用います。全体の要約を行う場合には、summarise()のみを用いることもあります。例えば、dfのvalueの合計を求めるには以下のようにします。 summarise(df, total = sum(value), .groups = &quot;drop&quot;) ## total ## 1 15 第3引数の.groups = \"drop\"は、要約後にグループ化の情報を残すかどうかの設定となります。特に必要が無ければ\"drop\"を指定しておくとよいでしょう。 colorごとに合計を求めるには、group_by()でグループ化を行ってから、summarise()で要約を行います。group_by()を実行することで、テーブルにグループ化された変数についての情報が付加されます。 by_color &lt;- group_by(df, color) by_color ## # A tibble: 5 x 2 ## # Groups: color [2] ## color value ## &lt;chr&gt; &lt;int&gt; ## 1 blue 1 ## 2 black 2 ## 3 blue 3 ## 4 blue 4 ## 5 black 5 この出力は、color列に2つのグループが設定されていることを示しています。この結果に対してsummarise()を適用すれば、グループごとの要約ができます。 summarise(by_color, total = sum(value), .groups = &quot;drop&quot;) ## # A tibble: 2 x 2 ## color total ## &lt;chr&gt; &lt;int&gt; ## 1 black 7 ## 2 blue 8 複数の列の値の組み合わせでグループ分けを行う場合には、それらの列名をgroup_by()の第2引数以降に並べます。 by_date &lt;- group_by(flights, year, month, day) by_date ## # A tibble: 336,776 x 19 ## # Groups: year, month, day [365] ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # ... with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 要約のための関数には以下のようなものがあります。 関数 説明 min(x), max(x) xの最大値、最小値 median(x) xの中央値 n() グループごとの件数 n_distinct() グループごとのユニークな行数 sum(x), mean(x) xの合計、平均値 sum(x &gt; 10) x &gt; 10を満たす行数 mean(x &gt; 10) x &gt; 10を満たす比率 sd(x), var(x) xの標準偏差、分散 "],["pipe.html", "3.5 パイプ", " 3.5 パイプ 以下のように、複数のverbを続けて実行すると、可読性が悪くなります。どのような処理をしているのでしょうか。 hourly_delay &lt;- filter( summarise( group_by( filter( flights, !is.na(dep_delay) ), year, month, day, hour ), delay = mean(dep_delay), n = n(), .groups = &quot;drop&quot; ), n &gt; 10 ) magrittrパッケージ（dplyrが入っていればインストールされている）で提供されているパイプ演算子を用いると、このような処理を簡潔に記述できる。一般に、ある関数f()をオブジェクトxに引数yを伴って適用する場合、 x %&gt;% f(y) と記述すれば f(x, y) を実行したことになります。パイプはいくつも続けて適用することができるため、上の処理は hourly_delay &lt;- flights %&gt;% filter(!is.na(dep_delay)) %&gt;% group_by(year, month, day, hour) %&gt;% summarise(delay = mean(dep_delay), n = n(), .groups = &quot;drop&quot;) %&gt;% filter(n &gt; 10) hourly_delay ## # A tibble: 5,813 x 6 ## year month day hour delay n ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 6 2.16 51 ## 2 2013 1 1 7 3.51 49 ## 3 2013 1 1 8 0.448 58 ## 4 2013 1 1 9 5.34 56 ## 5 2013 1 1 10 0.333 39 ## 6 2013 1 1 11 3.19 37 ## 7 2013 1 1 12 5.75 56 ## 8 2013 1 1 13 20.4 54 ## 9 2013 1 1 14 17.2 48 ## 10 2013 1 1 15 7.77 66 ## # ... with 5,803 more rows のように記述できます。 "],["dplyr-tidyr-02.html", "4 dplyr/tidyrを用いたデータの整理と変換(2) ", " 4 dplyr/tidyrを用いたデータの整理と変換(2) "],["two-table-verbs.html", "4.1 2つのテーブルを結合するverb", " 4.1 2つのテーブルを結合するverb 2つのテーブルを、共通するIDなどを用いて結合するためのverbがあります。テーブル内で、ある変数の値を用いることで行を一意に特定できる変数のことをキー（Key）と呼びます。その中で、特に設計者が最も好ましいものとして選択したものを主キー（Primary Key）と呼びます。例えば、以下のようなテーブル「users」であればIDはキーとなります。 usersテーブル ID gcode A001 2 A002 1 A003 1 A004 2 A005 1 キーは単一の変数である必要はなく、複数変数の組み合わせによってキーとなることもあります。例えば、1日分の情報が1行となっているデータにおいて、年と月と日が異なる変数になっている場合には、3つの変数の組み合わせによってキーとなります。 上のテーブルで、gcodeは性別のコードを表していて、実際の性別の情報が以下のテーブル「gender」に格納されているとします。 genderテーブル gcode gender 1 女性 2 男性 このとき、usersテーブルにおけるgcodeは別のテーブルであるgenderテーブルのキーとなっており、usersテーブルの外部キーと呼ばれます。2つのテーブルの結合多くの場合、この外部キーを利用して行われます。 dplyrパッケージにおいて、2つのテーブルxとyを結合するためのverbは、 xxxxx_join(x, y) の形で用います。xxxxxの部分は以下のようなものがあります。 verb 結合方法 inner_join() xの外部キーの値とyのキーの値が一致するxとyの行を結合して出力 left_join() inner_join()で出力される行に加えて、xの外部キーの値がyのキー値のいずれにも一致しないxの行も出力される。これらの行に対応するyの変数の値はNAとなる。 right_join() inner_join()で出力される行に加えて、yの外部キーの値がxのキー値のいずれにも一致しないxの行も出力される。これらの行に対応するxの変数の値はNAとなる。 semi_join() xの外部キーの値とyのキーの値が一致するxの行を出力 anti_join() xの外部キーの値とyのキーの値が一致しないxの行を出力。semi_join()のxに関する補集合になる。 これらの動作を確認するために、以下のようにサンプルデータを作成します。 users &lt;- data.frame( id = paste0(&quot;A00&quot;, 1:6), gcode = c(2, 1, 1, 2, 1, 3) ) gender &lt;- data.frame( gcode = 1:2, gender = c(&quot;女性&quot;, &quot;男性&quot;) ) resp &lt;- data.frame( id = paste0(&quot;A00&quot;, c(1, 2, 4, 5)), Q1 = c(5, 3, 3, 2), Q2 = c(2, 3, 5, 5) ) answer &lt;- data.frame( acode = 1:5, answer = c(&quot;全く当てはまらない&quot;, &quot;当てはまらない&quot;, &quot;どちらでもない&quot;, &quot;当てはまる&quot;, &quot;とても当てはまる&quot;) ) inner_join()関数でusersのidとrespのidが一致するusersの行とrespの行を結合したものを出力します。 inner_join(users, resp) ## Joining, by = &quot;id&quot; ## id gcode Q1 Q2 ## 1 A001 2 5 2 ## 2 A002 1 3 3 ## 3 A004 2 3 5 ## 4 A005 1 2 5 left_join()関数でusersの全ての行に、respのidが一致するrespの行を結合したものを出力します。usersの行のうち、respのidと一致しない行については、respの列の値がNAとなります。 left_join(users, resp) ## Joining, by = &quot;id&quot; ## id gcode Q1 Q2 ## 1 A001 2 5 2 ## 2 A002 1 3 3 ## 3 A003 1 NA NA ## 4 A004 2 3 5 ## 5 A005 1 2 5 ## 6 A006 3 NA NA semi_join()関数は、inner_join()関数と同様にusersのidとrespのidが一致するusersの行を出力しますが、対応するrespの結合は行われません。 semi_join(users, resp) ## Joining, by = &quot;id&quot; ## id gcode ## 1 A001 2 ## 2 A002 1 ## 3 A004 2 ## 4 A005 1 anti_join()関数は、usersのidとrespのidが一致しないusersの行を出力します。 anti_join(users, resp) ## Joining, by = &quot;id&quot; ## id gcode ## 1 A003 1 ## 2 A006 3 これらの関数をパイプで繋ぐことで、以下のような出力を得ることができます。left_join()関数の引数byは、外部キーと参照先のキーの変数名が異なる場合に指定します。指定しなければ、同じ変数名の列が外部キーおよび参照先のキー列として処理されます。rename()関数は、列名を変更するためのものです。 left_join(users, gender) %&gt;% left_join(resp) %&gt;% left_join(answer, by = c(&quot;Q1&quot; = &quot;acode&quot;)) %&gt;% rename(q1a = answer) %&gt;% left_join(answer, by = c(&quot;Q2&quot; = &quot;acode&quot;)) %&gt;% rename(q2a = answer) %&gt;% select(id, gender, ends_with(&quot;a&quot;)) ## Joining, by = &quot;gcode&quot; ## Joining, by = &quot;id&quot; ## id gender q1a q2a ## 1 A001 男性 とても当てはまる 当てはまらない ## 2 A002 女性 どちらでもない どちらでもない ## 3 A003 女性 &lt;NA&gt; &lt;NA&gt; ## 4 A004 男性 どちらでもない とても当てはまる ## 5 A005 女性 当てはまらない とても当てはまる ## 6 A006 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; nycflights13パッケージには、flightsデータの他に、空港の情報が集約されたairportsデータが含まれています。例えば、空港ごとの遅延に関する要約を地図上に可視化したいような場合、空港の緯度経度の情報はairportsの方に含まれているため、これら両方のテーブルを結合したうえで分析する必要があります。 flights %&gt;% group_by(dest) %&gt;% summarise( arr_delay = mean(arr_delay, na.rm = TRUE), n = n(), .groups = &quot;drop&quot; ) %&gt;% left_join(airports, by = c(&quot;dest&quot; = &quot;faa&quot;)) ## # A tibble: 105 x 10 ## dest arr_delay n name lat lon alt tz dst tzone ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 ABQ 4.38 254 Albuquerque In~ 35.0 -107. 5355 -7 A America~ ## 2 ACK 4.85 265 Nantucket Mem 41.3 -70.1 48 -5 A America~ ## 3 ALB 14.4 439 Albany Intl 42.7 -73.8 285 -5 A America~ ## 4 ANC -2.5 8 Ted Stevens An~ 61.2 -150. 152 -9 A America~ ## 5 ATL 11.3 17215 Hartsfield Jac~ 33.6 -84.4 1026 -5 A America~ ## 6 AUS 6.02 2439 Austin Bergstr~ 30.2 -97.7 542 -6 A America~ ## 7 AVL 8.00 275 Asheville Regi~ 35.4 -82.5 2165 -5 A America~ ## 8 BDL 7.05 443 Bradley Intl 41.9 -72.7 173 -5 A America~ ## 9 BGR 8.03 375 Bangor Intl 44.8 -68.8 192 -5 A America~ ## 10 BHM 16.9 297 Birmingham Intl 33.6 -86.8 644 -6 A America~ ## # ... with 95 more rows また、weatherデータには、出発地（EWR：ニューアークリバティー国際空港）における時間ごとの温度、湿度、風速、降雨量などの情報が含まれています。これらの気象条件と飛行機の遅延に関する分析を行いたいような場合でも、テーブルの結合処理が必要となります。 flights %&gt;% group_by(year, month, day, hour) %&gt;% summarise( arr_delay = mean(arr_delay, na.rm = TRUE), n = n(), .groups = &quot;drop&quot; ) %&gt;% left_join(weather) ## Joining, by = c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;) ## # A tibble: 20,720 x 17 ## year month day hour arr_delay n origin temp dewp humid wind_dir ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 5 9 6 EWR 39.0 28.0 64.4 260 ## 2 2013 1 1 5 9 6 JFK 39.0 27.0 61.6 260 ## 3 2013 1 1 5 9 6 LGA 39.9 25.0 54.8 250 ## 4 2013 1 1 6 3.78 52 EWR 37.9 28.0 67.2 240 ## 5 2013 1 1 6 3.78 52 JFK 37.9 27.0 64.3 260 ## 6 2013 1 1 6 3.78 52 LGA 39.9 25.0 54.8 260 ## 7 2013 1 1 7 3.76 49 EWR 39.0 28.0 64.4 240 ## 8 2013 1 1 7 3.76 49 JFK 39.0 28.0 64.4 260 ## 9 2013 1 1 7 3.76 49 LGA 39.9 26.1 57.3 250 ## 10 2013 1 1 8 -2.40 58 EWR 39.9 28.0 62.2 250 ## # ... with 20,710 more rows, and 6 more variables: wind_speed &lt;dbl&gt;, ## # wind_gust &lt;dbl&gt;, precip &lt;dbl&gt;, pressure &lt;dbl&gt;, visib &lt;dbl&gt;, ## # time_hour &lt;dttm&gt; "],["dplyr-tidyr-03.html", "5 dplyr/tidyrを用いたデータの整理と変換(3) ", " 5 dplyr/tidyrを用いたデータの整理と変換(3) "],["tidydata.html", "5.1 tidydataとは？", " 5.1 tidydataとは？ 以下の原則を満たすデータを、tidydataと呼びます。 各変数には専用の列がある 各観測には専用の行がある 各値は専用のセルにある データはさまざまな形で提供されますが、tidydataの形式に変換することで、分析や可視化がスムーズに行えるようになります。tidyverseに含まれるパッケージ群は、tidydataを前提とした関数を提供しています。その中でも、tidyでないデータをtidydataに変換する関数を提供するパッケージがtidyrパッケージです。 例えば、以下のようなデータはtidydataです。 table1 &lt;- tibble( country = c(&quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Brazil&quot;, &quot;Brazil&quot;, &quot;China&quot;, &quot;China&quot;), year = rep(c(1999L, 2000L), 3), cases = c(745L, 2666L, 37737L, 80488L, 212258L, 213766L), population = c(19987071L, 20595360L, 172006362L, 174504898L, 1272915272L, 1280428583L) ) country year cases population Afghanistan 1999 745 19987071 Afghanistan 2000 2666 20595360 Brazil 1999 37737 172006362 Brazil 2000 80488 174504898 China 1999 212258 1272915272 China 2000 213766 1280428583 以下のデータは、casesとpopulationの値がcountに混在しており、それぞれが専用の列をもたない形になっているため、tidydataではありません。 table2 &lt;- table1 %&gt;% pivot_longer(c(cases, population), names_to = &quot;key&quot;, values_to = &quot;value&quot;) %&gt;% arrange(country, year) country year key value Afghanistan 1999 cases 745 Afghanistan 1999 population 19987071 Afghanistan 2000 cases 2666 Afghanistan 2000 population 20595360 Brazil 1999 cases 37737 Brazil 1999 population 172006362 Brazil 2000 cases 80488 Brazil 2000 population 174504898 China 1999 cases 212258 China 1999 population 1272915272 China 2000 cases 213766 China 2000 population 1280428583 以下のデータは、rateの列におけるそれぞれのセルに複数の値が含まれているため、tidydataではありません。 table3 &lt;- table1 %&gt;% unite(rate, cases, population, sep = &quot;/&quot;) country year rate Afghanistan 1999 745/19987071 Afghanistan 2000 2666/20595360 Brazil 1999 37737/172006362 Brazil 2000 80488/174504898 China 1999 212258/1272915272 China 2000 213766/1280428583 以下のデータは、2つのテーブルにデータがまたがっているため、tidydataではありません。 table4a &lt;- table1 %&gt;% select(-population) %&gt;% pivot_wider(names_from = year, values_from = cases) country 1999 2000 Afghanistan 745 2666 Brazil 37737 80488 China 212258 213766 table4b &lt;- table1 %&gt;% select(-cases) %&gt;% pivot_wider(names_from = year, values_from = population) country 1999 2000 Afghanistan 19987071 20595360 Brazil 172006362 174504898 China 1272915272 1280428583 "],["long-wide.html", "5.2 縦長（long）データと横長（wide）データの相互変換", " 5.2 縦長（long）データと横長（wide）データの相互変換 5.2.1 pivot_longer()関数を用いたwideからlongへの変換 table4aやtable4bは、列名が1999や2000というように「年」に関する変数の観測値となっています。また、テーブル内部の数値は、table4aの場合casesの観測値、table4bの場合はpopulationの観測値というように、単一の変数の観測値が複数列にまたがっています。このような形のテーブルとなっているデータのことを横長（wide型）データと呼びます。 knitr::kable(table4a) country 1999 2000 Afghanistan 745 2666 Brazil 37737 80488 China 212258 213766 このデータを、year列に「年」の観測値（1999もしくは2000）、cases列にcasesの観測値を格納する形式、すなわち縦長（long型）データに変換するには、pivot_longer()関数を用います。 pivot_longer()関数の第1引数はdplyrのverbと同様にデータフレームとなります。また、関数を適用した結果もデータフレームになりますので、パイプ処理の中で利用できます。第2引数に、観測値が列名となっている列の一覧をdplyrのselect()関数で変数を選択する場合と同様の形式（ただし、複数の変数の列挙はc()関数を使う）で与えます。また、それらに対する新たに設定する変数名をnames_to引数に文字列として指定し、それらの値に対して新たに設定する変数名をvalues_to引数に文字列として指定します。table4aに対しては、例えば以下のようにします。 table4a %&gt;% pivot_longer(-country, names_to = &quot;year&quot;, values_to = &quot;cases&quot;) ## # A tibble: 6 x 3 ## country year cases ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 2000 2666 ## 3 Brazil 1999 37737 ## 4 Brazil 2000 80488 ## 5 China 1999 212258 ## 6 China 2000 213766 観測値が列名となっている列の一覧は、c(1999,2000)のような形式でもいいですが、ここではcountry以外のすべての列ということで、-countryとしています。また、names_toとvalues_toは、新たに設定する変数名であり、table4aに含まれる列名ではありませんので、ダブルクォートをつけて文字列として指定する必要があります。 5.2.2 pivot_wider()関数を用いたwideからlongへの変換 table2は1つの観測（各国の1年分の観測）が2行にまたがっています。これはtidydataの1行が1観測という原則を満たしておらず、tidydataではありません。これをtidydataにするためには、count列を広げてkey列の値を変数名とした新たな列を作成する必要があります。 knitr::kable(table2) country year key value Afghanistan 1999 cases 745 Afghanistan 1999 population 19987071 Afghanistan 2000 cases 2666 Afghanistan 2000 population 20595360 Brazil 1999 cases 37737 Brazil 1999 population 172006362 Brazil 2000 cases 80488 Brazil 2000 population 174504898 China 1999 cases 212258 China 1999 population 1272915272 China 2000 cases 213766 China 2000 population 1280428583 これは、前のセクションにおけるpivot_longer()と逆の操作に相当し、long形式からwide形式への変換となります。これを行うのがpivot_wider()関数です。 pivot_wider()関数もpivot_longer()関数と同様にパイプ処理の中で利用できます。names_from引数に変数名を含む列（ここではkey）、values_from引数にそれらの変数名に対応した値が格納されている列（ここではcount）を指定します。これらは、データフレーム内の変数名ですので、ダブルクォートはつけません。table2に対しては例えば以下のようにします。 table2 %&gt;% pivot_wider(names_from = key, values_from = value) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 "],["unite-and-separate.html", "5.3 列の分割と結合", " 5.3 列の分割と結合 table3はrateの列に複数の変数（populationとcases）の情報が文字列として格納されており、tidyではありません。このようにひとつの列に含まれている文字列を、複数の列に分割したい場合は、separate()関数を用います。separate()関数は、dplyrのverbと同様に、第1引数はデータフレームで、出力もデータフレームです。第1引数以外で必要な引数としては，分割元の変数を指定するcolと分割した後に設定する変数名のベクトルintoとなります。table3の場合、colにrate、intoにc(\"cases\", \"population\")を指定します。 table3 ## # A tibble: 6 x 3 ## country year rate ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 table3 %&gt;% separate(rate, c(&quot;cases&quot;, &quot;population&quot;)) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 これでもOKですが、分割された後の変数が文字列になっているので、数字のみの文字列であれば、convert引数をTRUEに設定すると、数値に変換してくれます。 table3 %&gt;% separate(rate, c(&quot;cases&quot;, &quot;population&quot;), convert = TRUE) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 また、区切り文字については、デフォルトでは数値以外の文字となっていますが、指定したい場合は、sep引数を指定します。（table3の場合は指定しなくてもOKです。） table3 %&gt;% separate(rate, c(&quot;cases&quot;, &quot;population&quot;), sep = &quot;/&quot;) separate()関数とは反対に、複数の変数をひとつの列に結合したい場合は、unite()関数を用います。ここでは、unite()関数の動作確認のために、table3のyearを先頭2桁のcenturyと後ろ2桁のyearに分割をしてから、再度結合することを考えます。sep引数に数値を与えると、その数値の桁数分で分割されます。 table5 &lt;- table3 %&gt;% separate(year, c(&quot;century&quot;, &quot;year&quot;, sep = 2)) ## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 6 rows [1, 2, 3, 4, ## 5, 6]. table5 ## # A tibble: 6 x 5 ## country century year `2` rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 &lt;NA&gt; &lt;NA&gt; 745/19987071 ## 2 Afghanistan 2000 &lt;NA&gt; &lt;NA&gt; 2666/20595360 ## 3 Brazil 1999 &lt;NA&gt; &lt;NA&gt; 37737/172006362 ## 4 Brazil 2000 &lt;NA&gt; &lt;NA&gt; 80488/174504898 ## 5 China 1999 &lt;NA&gt; &lt;NA&gt; 212258/1272915272 ## 6 China 2000 &lt;NA&gt; &lt;NA&gt; 213766/1280428583 centuryとyearの列をunite()関数で結合して、改めてyear列とします。unite()関数もdplyrのverbと同様に、第1引数はデータフレームで、出力もデータフレームです。第1引数以外で必要な引数としては，結合後の変数名colと、select()と同様に指定された結合対象の変数名となります。 table5 %&gt;% unite(col = new, century, year) ## # A tibble: 6 x 4 ## country new `2` rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999_NA &lt;NA&gt; 745/19987071 ## 2 Afghanistan 2000_NA &lt;NA&gt; 2666/20595360 ## 3 Brazil 1999_NA &lt;NA&gt; 37737/172006362 ## 4 Brazil 2000_NA &lt;NA&gt; 80488/174504898 ## 5 China 1999_NA &lt;NA&gt; 212258/1272915272 ## 6 China 2000_NA &lt;NA&gt; 213766/1280428583 このように、デフォルトではアンダースコア_によって結合されますが、結合文字を指定したい場合はsep変数を指定します（以下の例は空の文字列）。 table5 %&gt;% unite(col = new, century, year, sep = &quot;&quot;) ## # A tibble: 6 x 4 ## country new `2` rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999NA &lt;NA&gt; 745/19987071 ## 2 Afghanistan 2000NA &lt;NA&gt; 2666/20595360 ## 3 Brazil 1999NA &lt;NA&gt; 37737/172006362 ## 4 Brazil 2000NA &lt;NA&gt; 80488/174504898 ## 5 China 1999NA &lt;NA&gt; 212258/1272915272 ## 6 China 2000NA &lt;NA&gt; 213766/1280428583 "],["ggplot2-01.html", "6 ggplot2によるデータの可視化（1） ", " 6 ggplot2によるデータの可視化（1） "],["about-ggplot2.html", "6.1 ggplot2パッケージについて", " 6.1 ggplot2パッケージについて ggplot2パッケージは、Wilkinson(2005)による“Grammar of Graphics”の理論に基づいてデータを可視化する機能を提供します。パッケージの開発者はdplyrパッケージと同じHadley Wickhamです。ggplot2は、可視化のための一貫した文法を提供するだけでなく、グラフの出力が洗練されていることから、多くの支持を集めています。 ggplot2はtidyverseに含まれているので、tidyverseが利用可能な状態であればggplot2の関数は利用できます。このテキストでは、ggplot2の2020年10月時点での最新版3.2.2の利用を前提に説明します。 "],["basics-ggplot2.html", "6.2 ggplot2における可視化の基本", " 6.2 ggplot2における可視化の基本 Rの標準機能で提供されるplot()関数では、引数に描画したいデータが含まれるベクトルを指定します。一方、ggplot2においては、描画したいデータが含まれるデータフレームを指定するのが基本です。その上で、描画したいグラフの種類（geoms）と、グラフの描画要素（aesthetics）にデータフレーム内のどの変数を割り当てるかを記述します。ここでは、ggplot2に含まれるmpgデータを用いて説明します。mpgデータには1999年から2008年の間に毎年新しい車種を発売している主要な38のモデルについて、1999年と2008年の燃費などの値が記録されています。以下のコマンドにより、一般の道路における燃費ctyと高速道路における燃費hwy（単位はいずれもmiles per gallon）の散布図を描画できます。 ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point() まず、ggplot()関数のdata引数にデータフレームを指定し、mapping引数に、aes()関数を用いて、aestheticsへの対応を記述します。ただ、これだけでは、グラフは描画されません。ggplot()関数は、グラフの基本情報を設定するための関数と考えればよいでしょう。この情報にgeomsの情報を+演算子によって加えることで、実際にグラフが描画されます。ggplot2では、このように、グラフに対して新たな情報や機能を付加する場合、具体的には レイヤー（プロットやラベルや見出し）を追加 設定（グラフ全体のスタイルなど）を追加 座標系の変更 層別プロット（facet）の作成 をしたい場合に、+演算子でコマンドを接続するというスタイルをとっています。geom_point()関数は、aesで指定したxとyの各要素の組を平面上の点としてプロットするという命令です（つまり散布図を描画）。上のコマンドは、引数名を省略して記述すると以下のようになります。 ggplot(mpg, aes(cty, hwy)) + geom_point() aes()関数の第1、第2引数はそれぞれxとyとの対応となっていますが、それ以降の引数に、描画要素の大きさ（size）や色（color）などへの対応を記述することができます。また、aestheticsはgeomsの方で記述することもできます。以下のようにすれば、classごとに色分けされた散布図が描画されます。 p &lt;- ggplot(mpg, aes(cty, hwy)) p + geom_point(aes(color = class)) また、size = displとすれば、排気量（displ）の値に応じた大きさで散布図の点がプロットされます。 p + geom_point(aes(size = displ)) geom_point()関数はグラフィックスとして点を追加するための関数ですが、これ以外にも geom_bar()：棒グラフ geom_boxplot()：箱ひげ図 geom_histogram()：ヒストグラム geom_line()：折れ線グラフ などの関数が用意されています。使い方については、以降のセクションで説明していきます。 "],["ggplot-barplot.html", "6.3 棒グラフ", " 6.3 棒グラフ ggplot2で棒グラフを作成するにはgeom_bar()関数を使います。棒グラフは、質的変数に対する頻度や比例尺度での集計値を示すグラフです。標準では、aesとして1つの質的変数のみを指定します。例えば、mpgデータでclassごとの度数を棒グラフにしたい場合は次のようにします。 ggplot(mpg, aes(x = class)) + geom_bar() 散布図の場合は、xとyに指定された変数の値がそのままプロットされましたが、棒グラフの場合は、指定した質的変数（class）の度数を集計してからプロットするという流れになっています。これは、ggplot2のグラフ描画関数に連動する統計変換（Statistical Transformation）が実行される仕組みになっているためです。棒グラフの場合は度数の計算（count）ですが、ヒストグラムの場合は階級ごとの度数（bin）、箱ひげ図の場合は分位点（boxplotというように、標準での統計処理が定められています。これらは標準設定であり、データの与えられ方によっては変更すべき場合があります。例えば、以下のように、度数がすでに計算されており、個人ごとのデータがないような場合には、統計変換をしない（identity）設定にして、aesのxとyにそれぞれ、質的変数と度数を与えることによって棒グラフを描画することができます5。 fwu &lt;- data.frame( dept = c(&quot;国際教養学科&quot;, &quot;環境科学科&quot;, &quot;食・健康学科&quot;), students = c(605, 283, 148) ) fwu ## dept students ## 1 国際教養学科 605 ## 2 環境科学科 283 ## 3 食・健康学科 148 ggplot(fwu, aes(dept, students)) + geom_bar(stat = &quot;identity&quot;) geom_bar()でstat = \"identity\"とする代わりに、geom_col()を用いて、 ggplot(fwu, aes(dept, students)) + geom_col() とすることもできます。例えば、構成比率を棒グラフにしたい場合は、以下のようにするとよいでしょう。 mpg %&gt;% group_by(class) %&gt;% summarise(n = n(), .groups = &quot;drop&quot;) %&gt;% mutate(prop = n / sum(n)) %&gt;% ggplot() + geom_col(aes(class, prop)) 6.3.1 帯グラフと集合縦棒グラフ geom_bar()関数では、position引数を使うことによって、集合縦棒グラフ（position = \"dodge\"）や帯グラフ（position = fill）を描画することができます。この場合、aesのfillに塗り分けたい（層別したい）質的変数を指定します。例えば集合縦棒グラフの場合は以下のようにします。 ggplot(mpg, aes(class, fill = drv)) + geom_bar(position = &quot;dodge&quot;) また、帯グラフの場合は以下のようになります。 ggplot(mpg, aes(class, fill = drv)) + geom_bar(position = &quot;fill&quot;) geom_bar()関数におけるposition引数のデフォルト設定はstackであり、positionを指定せずにaesのfillを指定すると以下のように、積み上げ縦棒グラフが描画されます。 ggplot(mpg, aes(class, fill = drv)) + geom_bar() 6.3.2 カテゴリ（因子型の水準）の並べ替え geom_bar()関数は、x軸の質的変数を因子型に設定されたカテゴリの順番で描画します。その変数が名義尺度の場合は、頻度の順番で並べ替えた方がいいです。これを簡単に行うには、forcatsパッケージ（これもtidyverseに含まれています）を使います。例えば、mpgでclassの頻度順に因子型の水準の順番を並べ替えるにはfct_infreq()関数を以下のように適用します。 ggplot(mpg, aes(fct_infreq(class))) + geom_bar() 一方、頻度を集計した後のfwuデータでは、因子型の水準を集計された別の変数（ここではstudents）の順番で並べ替えるようにします。この場合は、fct_reorder()関数を以下のように適用します。 ggplot(fwu, aes(fct_reorder(dept, -students), students)) + geom_bar(stat = &quot;identity&quot;) -studentsとなっているのは、fct_reorder()関数が昇順で並べ替えるため、studentsの符号を反転したものを昇順に並べ替えることで、studentsを降順で並べ替えるようにしているからです。 散布図を描画するgeom_point()の標準の統計変換はidentityとなっています。↩︎ "],["ggplot-hist-box.html", "6.4 ヒストグラムと箱ひげ図", " 6.4 ヒストグラムと箱ひげ図 1つの量的変数の分布をみる場合はヒストグラムを使います。ggplot2では、geom_hist()関数を用います。mpgデータで高速道路の燃費hwyの分布をみる場合は以下のようにします。 ggplot(mpg, aes(hwy)) + geom_histogram(binwidth = 2) binwidthは階級幅になります。指定しない場合は自動で設定されますが、警告表示が出力されます。 質的変数のカテゴリごとの量的変数の分布を見たい場合は、箱ひげ図を使います。ggplot2では、geom_boxplot()関数を使います。mpgデータで、classごとのhwyの分布をみる場合は以下のようにします。 ggplot(mpg, aes(class, hwy)) + geom_boxplot() "],["ggplot-line.html", "6.5 折れ線グラフ", " 6.5 折れ線グラフ 折れ線グラフは経過時間に伴って変化する量的変数を示すグラフです。ここでは、3つのパターンについて紹介します。 6.5.1 x軸が経過時間、y軸が1つの変数 この場合が折れ線グラフの基本となります。折れ線グラフはgeom_line()関数で描画します。 df_time &lt;- data.frame(t = 1:10, y = rnorm(10)) df_time ## t y ## 1 1 0.2365249 ## 2 2 0.5969464 ## 3 3 -0.8829657 ## 4 4 0.8606371 ## 5 5 -0.9484992 ## 6 6 0.1541834 ## 7 7 0.8404190 ## 8 8 1.3756371 ## 9 9 0.2202995 ## 10 10 0.1912124 ggplot(df_time, aes(t, y)) + geom_line() flightsデータの場合に、月ごとの平均遅延時間をプロットするには以下のようにします。 flights %&gt;% filter(!is.na(arr_delay)) %&gt;% group_by(month) %&gt;% summarise(arr_delay = mean(arr_delay), .group = &quot;drop&quot;) %&gt;% ggplot(aes(month, arr_delay)) + geom_line() + scale_x_continuous(breaks = 1:12) 最終行のscale_x_continuous()は、x軸の目盛りを設定するためのものです。 6.5.2 x軸が経過時間、y軸が2つ以上の変数 2つ以上の量的変数の時間推移を見たい場合は、geom_line()のaesにおいてgroupを指定します。 df_time &lt;- df_time %&gt;% mutate(z = rnorm(10)) df_time ## t y z ## 1 1 0.2365249 1.1301350 ## 2 2 0.5969464 0.6943941 ## 3 3 -0.8829657 0.5728963 ## 4 4 0.8606371 0.6692558 ## 5 5 -0.9484992 -0.1335879 ## 6 6 0.1541834 0.1261127 ## 7 7 0.8404190 2.0127508 ## 8 8 1.3756371 -0.3750516 ## 9 9 0.2202995 0.7186727 ## 10 10 0.1912124 -0.2805223 変数が異なる列に格納されている（横長データ）の場合、一旦縦長に変形して、列名となっていた変数をgroupに指定します。 df_time %&gt;% pivot_longer(-t, names_to = &quot;var&quot;, values_to =&quot;value&quot;) %&gt;% ggplot(aes(t, value, group = var, color = var)) + geom_line() 6.5.3 x軸が日付、y軸が2つ以上の変数 以上の例は、x軸は単なる数値でしたが、時間変化のデータの場合、日付であることも多いです。例として以下のようなデータを考えます。 fuk_temp &lt;- read.csv(&quot;./data/fukuoka_temp.csv&quot;, encoding = &quot;UTF-8&quot;) head(fuk_temp) ## 年月 平均気温 日最高気温の平均 日最低気温の平均 ## 1 2010/1/1 6.6 10.3 3.3 ## 2 2010/2/1 9.4 13.1 6.0 ## 3 2010/3/1 10.9 14.3 7.6 ## 4 2010/4/1 13.8 18.1 10.3 ## 5 2010/5/1 19.2 23.6 15.6 ## 6 2010/6/1 23.5 27.6 20.7 年月列に文字列として2010/1/1のような形式で日付の情報が格納されています。このままだと、文字列なので正常に折れ線グラフが描画されません。文字列を日付としてのデータ型に変換する場合は、lubridateパッケージのas_date()関数を用います。lubridateパッケージもtidyverseに含まれていますが、ロードは同時にされませんので、パッケージの関数を利用することを明示しておきます。 fuk_temp %&gt;% pivot_longer(-年月, names_to = &quot;type&quot;, values_to = &quot;temp&quot;) %&gt;% mutate(年月 = lubridate::as_date(年月)) %&gt;% ggplot(aes(年月, temp, group = type, color = type)) + geom_line() + scale_x_date(labels = scales::date_format(&quot;%Y/%m&quot;)) + labs(title = &quot;福岡市の気温&quot;) "],["ggplot2-02.html", "7 ggplot2によるデータの可視化（2） ", " 7 ggplot2によるデータの可視化（2） "],["facet.html", "7.1 層別", " 7.1 層別 ggplot2における特徴的な機能として層別（facetting^[直訳すると「小平面」などとなりますが、ここではデータ解析の目的に合わせて層別と呼ぶことにします）があります。これは、ある質的変数によってプロットを分割するものです。層別は、facet_grid()関数およびfacet_wrap()関数によって実現できます。1つの質的変数で層別する場合には、facet_wrap()関数を用います。以下の例は、classごとにdisplとhwyの散布図を2行のレイアウト（nrow = 2）に収まるように配置するものです。 ggplot(mpg, aes(displ, hwy)) + geom_point() + facet_wrap(~ class, nrow = 2) 2つの質的変数で層別したい場合には、facet_grid()関数を用います。以下の例は、drvとcylの値の組み合わせごとに、displとhwyの散布図を並べるものです。 ggplot(mpg, aes(displ, hwy)) + geom_point() + facet_grid(drv ~ cyl) "],["output.html", "7.2 出力の調整", " 7.2 出力の調整 7.2.1 テーマ プロットを出力するggplot2の一連のコマンドにtheme_**()を加えることで、プロットの外観についてのテーマを変更することができます。 ggplot(mpg, aes(drv)) + geom_bar() + theme_bw() ggplot(mpg, aes(drv)) + geom_bar() + theme_minimal() ggplot(mpg, aes(drv)) + geom_bar() + theme_dark() 7.2.2 軸ラベル、タイトルなど 軸ラベルはxlab()とylab()関数で設定することができます。また、タイトルやサブタイトル、キャプションはそれぞれ、labs()関数のtitle引数、subtitle引数、caption引数で設定することができます。キャプションには、データの出典などを記述するとよいでしょう。 ggplot(mpg, aes(drv)) + geom_bar() + theme_minimal() + xlab(&quot;drive train&quot;) + ylab(&quot;度数&quot;) + labs(title = &quot;駆動装置の種別ごとの新車数の集計&quot;, subtitle = &quot;1999年と2008年にアメリカで発売された新車データより&quot;, caption = &quot;データ出典：http://fueleconomy.gov/&quot;) 7.2.3 フォントサイズの調整 出力したプロットをプレゼンテーションのスライドなどで利用したい場合には、そのままではフォントサイズが小さいことが多いです。全体のフォントサイズを大きくするには、theme_***()の中で、base_size引数を指定します。標準のテーマを用いる場合は、theme_grey()を利用してください。 ggplot(mpg, aes(drv)) + geom_bar() + theme_minimal(base_size = 16) 7.2.4 【Advanced】パワポにグラフをいい感じで貼り付ける パワーポイントのスライドにグラフを貼り付ける場合、基本的には画像としての貼り付けになりますので、貼り付けた後にパワーポイント上でフォントを変更したり、それ以外の見栄えを調整したりすることはできません。exportパッケージを利用すると、パワーポイントで編集可能な形式でグラフを出力することができます。ただし、exportパッケージは、Rの公式のパッケージサイトには登録されておらず、github6で公開されているため、パッケージインストールの手順がこれまでのものと異なります。まず、パッケージを管理するためのpacmanパッケージを以下の通りインストールします。 install.packages(&quot;pacman&quot;) その後、以下のコマンドでexportパッケージをインストールします。 pacman::p_load_gh(&quot;tomwenseleers/export&quot;) このコマンドでパッケージのインストールと読み込み（library()と同様の処理）が同時に行われますが、次回以降は library(export) で実行してください。 exportパッケージを使って、Rで表示させたプロットをパワーポイント形式のファイルで出力するには以下のようにします。 export::graph2ppt() これを実行すると、作業フォルダにRplot.pptxの名前のファイルが作成されて、スライドにグラフが出力されます。既存のファイルにグラフを追加する場合は、append = TRUEを引数に指定します。また、ファイル名を指定したい場合は、file = \"ファイル名.pptxとします。 オープンソースで開発されているソフトウェアのソースコードが公開されているサイト↩︎ "],["api01.html", "8 Webからのデータ取得（1）「e-Stat API」", " 8 Webからのデータ取得（1）「e-Stat API」 オープンデータとは以下の性質を持つデータ、あるいはその普及を目指す考え方のことを言います。 インターネット経由でダウンロードできる 再利用と再配布ができる 誰でも利用できる 使いやすく、変更可能な形式である 近年、この考え方に基づいて、様々なデータがインターネット上に公開されるようになりました。一方で、「使いやすく、変更可能な形式」という点においては、十分でないものも多いです。例えば、印刷されたデータをスキャンしたPDFファイルであれば、そのデータを利用したい場合には、利用者がエクセルなどに入力する必要があります。それがWordやExcelから変換されたものであったとしても、データ部分を抽出するには手間がかかってしまいます。一方、政府の統計データを公開しているe-Statにおいては、多くのエクセルファイルなどをダウンロードできるようになっていますが、印刷することを意識したレイアウトになっているものが多く、Rのデータフレームとして取り込むためには、無駄な部分を取り除いたり、列名を調整したりするなどの処理を手動で行う必要があります。 このような問題を解決できるのがApplication Programing Inteface（API）と呼ばれる仕組みです。APIを利用すると、あるプログラムやソフトウェア（ここでは、e-Statのデータを取得するためのプログラム）を外部のプログラム（ここではR）から呼び出して利用することができます。特に、利用したいプログラムやソフトウェアをインターネット経由で利用できるようになっている場合、そのAPIをWeb APIと呼ぶこともあります。APIを使うことで、例えば 独自のTwitterアプリを開発 独自のLINEのchatbotを開発 TwitterデータをRで直接取得 e-StatのデータをRで直接取得 などのことができるようになります。 "],["estatapi.html", "8.1 e-Stat API", " 8.1 e-Stat API ここでは、e-StatのAPI機能を使って、Rから直接e-Statのデータを取得する手順について紹介します。e-Stat APIでは、一部のデータを除き、e-Statで公開されている主要なデータを利用することができます。e-Stat APIで利用できるデータの一覧は以下のURLから確認できますので、データを探す際はこちらを参照するとよいでしょう。 https://www.e-stat.go.jp/stat-search/database e-StatのAPI機能を使うには、予めユーザー登録をしてアプリケーションIDを取得しておく必要があります。 e-Stat API機能 Rからe-Stat APIを使う際には、estatapiパッケージを利用します。初めて利用する場合は、インストールしておきます。 install.packages(&quot;estatapi&quot;) estatapiを利用するセッションでは、最初に library(estatapi) を実行しておきます。また、取得したアプリケーションIDは、estatapiパッケージの関数を呼び出すごとに用いますので、以下のように変数に入れておくとよいでしょう。 appId &lt;- &quot;取得したアプリケーションID&quot; 8.1.1 統計表の検索 e-Stat APIで利用可能な統計表を検索する場合はウェブサイトからの方が便利ですが、estatapiの関数でもestat_getStatsList()関数で検索できます。 search_result &lt;- estat_getStatsList(appId, &quot;チョコレート&quot;) 8.1.2 メタ情報の取得 指定した統計データに関する情報（データ本体ではなく、列名や変数のカテゴリに関する情報など）を取得するには、estat_getMetaInfo()関数を用います。ここでは、家計調査における品目分類ごとの支出額についてのデータを見てみましょう。データのIDは、前の表から、0003103532となっています。 metainfo_result &lt;- estat_getMetaInfo(appId, &quot;0003103532&quot;) 結果はリストで帰ってきますので、要素の一覧を確認します。 names(metainfo_result) ## [1] &quot;tab&quot; &quot;cat01&quot; &quot;cat02&quot; &quot;area&quot; &quot;time&quot; &quot;.names&quot; リストの要素ごとに中身を確認します。 metainfo_result$cat01 ## # A tibble: 703 x 5 ## `@code` `@name` `@level` `@unit` `@parentCode` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 000100000 世帯数分布（抽出率調整） 1 一万分比 &lt;NA&gt; ## 2 000200000 集計世帯数 1 世帯 &lt;NA&gt; ## 3 000300000 世帯人員 1 人 &lt;NA&gt; ## 4 000400000 18歳未満人員 2 人 000300000 ## 5 000500000 65歳以上人員 2 人 000300000 ## 6 000600000 65歳以上無職者人員 3 人 000500000 ## 7 000700000 有業人員 1 人 &lt;NA&gt; ## 8 000800000 世帯主の年齢 1 歳 &lt;NA&gt; ## 9 000900000 持家率 1 ％ &lt;NA&gt; ## 10 001000000 家賃・地代を支払っている世帯の割合 1 ％ &lt;NA&gt; ## # ... with 693 more rows metainfo_result$cat02 ## # A tibble: 4 x 3 ## `@code` `@name` `@level` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 03 二人以上の世帯（2000年～） 1 ## 2 04 二人以上の世帯のうち勤労者世帯（2000年～） 1 ## 3 01 二人以上の世帯（農林漁家世帯を除く）（1985年～2007年,2017年） 1 ## 4 02 二人以上の世帯のうち勤労者世帯（農林漁家世帯を除く）（1985年~ 1 metainfo_result$tab ## # A tibble: 1 x 3 ## `@code` `@name` `@level` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 01 金額 &quot;&quot; metainfo_result$area ## # A tibble: 53 x 3 ## `@code` `@name` `@level` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 00000 全国 1 ## 2 01003 01100 札幌市 1 ## 3 02003 02201 青森市 1 ## 4 03003 03201 盛岡市 1 ## 5 04003 04100 仙台市 1 ## 6 05003 05201 秋田市 1 ## 7 06003 06201 山形市 1 ## 8 07003 07201 福島市 1 ## 9 08003 08201 水戸市 1 ## 10 09003 09201 宇都宮市 1 ## # ... with 43 more rows metainfo_result$time ## # A tibble: 420 x 3 ## `@code` `@name` `@level` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1985000101 1985年1月 1 ## 2 1985000202 1985年2月 1 ## 3 1985000303 1985年3月 1 ## 4 1985000404 1985年4月 1 ## 5 1985000505 1985年5月 1 ## 6 1985000606 1985年6月 1 ## 7 1985000707 1985年7月 1 ## 8 1985000808 1985年8月 1 ## 9 1985000909 1985年9月 1 ## 10 1985001010 1985年10月 1 ## # ... with 410 more rows 分類品目において、「チョコレート」を含む分類を確認します。 metainfo_result$cat01 %&gt;% filter(str_detect(`@name`, &quot;チョコレート&quot;)) ## # A tibble: 2 x 5 ## `@code` `@name` `@level` `@unit` `@parentCode` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 010800130 352 チョコレート 5 円 010800000 ## 2 010800140 353 チョコレート菓子 5 円 010800000 8.1.3 統計データの取得 ここでは、チョコレート（010800130）の月別支出金額を見てみましょう。cdArea = \"00000\"は「全国」、cdCat01 = \"02\"は「2人以上の世帯」を指定しています。 choco &lt;- estat_getStatsData(appId, &quot;0003103532&quot;, cdArea = &quot;00000&quot;, cdCat01 = &quot;010800130&quot;, cdCat02 = &quot;03&quot;) ## Fetching record 1-240... (total: 240 records) このデータを使って、月別支出金額の折れ線グラフを作成してみます。 choco %&gt;% mutate(time = paste0(`時間軸（月次）`, &quot;1日&quot;)) %&gt;% mutate(time = lubridate::ymd(time)) %&gt;% ggplot(aes(time, value, group = 1)) + geom_line() + theme_minimal() 年毎の折れ線グラフを重ねて描画するには以下のようにします。 choco %&gt;% mutate(time = paste0(`時間軸（月次）`, &quot;1日&quot;)) %&gt;% mutate(time = lubridate::ymd(time)) %&gt;% mutate(year = lubridate::year(time)) %&gt;% mutate(month = lubridate::month(time)) %&gt;% ggplot(aes(month, value, group = year, color = factor(year))) + geom_line() + theme_minimal() + scale_x_continuous(breaks = 1:12) "],["aging-population.html", "8.2 【例1】少子高齢化の可視化", " 8.2 【例1】少子高齢化の可視化 e-Statのデータを用いて、少子高齢化の推移を可視化してみます。キーワード「人口」で検索して、「社会・人口統計体系」→「都道府県データ」→「年度次」 と辿り「Ａ 人口・世帯」の「API」をクリックするとデータのIDが0000010101であることが分かります。 メタデータを取得してデータの概要を確認します。 metainfo_result &lt;- estat_getMetaInfo(appId, &quot;0000010101&quot;) names(metainfo_result) ## [1] &quot;tab&quot; &quot;cat01&quot; &quot;area&quot; &quot;time&quot; &quot;.names&quot; head(metainfo_result$cat01) ## # A tibble: 6 x 4 ## `@code` `@name` `@level` `@unit` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 A1101 A1101_総人口 1 人 ## 2 A110101 A110101_総人口（男） 1 人 ## 3 A110102 A110102_総人口（女） 1 人 ## 4 A1102 A1102_日本人人口 1 人 ## 5 A110201 A110201_日本人人口（男） 1 人 ## 6 A110202 A110202_日本人人口（女） 1 人 metainfo_result$cat01 %&gt;% filter(`@code` &gt;= &quot;A1301&quot;, `@code` &lt;= &quot;A1303&quot;) ## # A tibble: 7 x 4 ## `@code` `@name` `@level` `@unit` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 A1301 A1301_15歳未満人口 1 人 ## 2 A130101 A130101_15歳未満人口（男） 1 人 ## 3 A130102 A130102_15歳未満人口（女） 1 人 ## 4 A1302 A1302_15～64歳人口 1 人 ## 5 A130201 A130201_15～64歳人口（男） 1 人 ## 6 A130202 A130202_15～64歳人口（女） 1 人 ## 7 A1303 A1303_65歳以上人口 1 人 metainfo_result$area ## # A tibble: 48 x 3 ## `@code` `@name` `@level` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 00000 全国 1 ## 2 01000 北海道 2 ## 3 02000 青森県 2 ## 4 03000 岩手県 2 ## 5 04000 宮城県 2 ## 6 05000 秋田県 2 ## 7 06000 山形県 2 ## 8 07000 福島県 2 ## 9 08000 茨城県 2 ## 10 09000 栃木県 2 ## # ... with 38 more rows 以上の情報から、以下のようにデータを取得します。cdCat01From = \"A1301\"とcdCat01To = \"A1303\"によって、「15歳未満」から「65歳以上」の集計カテゴリを取得するようにしています。cdArea = \"00000\"は「全国」を指定しています。 population &lt;- estat_getStatsData( appId, &quot;0000010101&quot;, cdCat01From = &quot;A1301&quot;, cdCat01To = &quot;A1303&quot;, cdArea = &quot;00000&quot; ) ## Fetching record 1-315... (total: 315 records) このデータから、積み上げ縦棒グラフを作成します。 population %&gt;% filter(str_length(cat01_code) == 5) %&gt;% ggplot(aes(調査年, value, fill = `Ａ 人口・世帯`)) + geom_bar(stat = &quot;identity&quot;) 見栄えを以下のように修正します。 年齢区分の表示「A1301_１５歳未満人口」→「15歳未満」 調査年の表示：切れのいい数字のみ（日付型に変換） 人口の目盛：指数表示→千人単位の通常表示 テーマ：minimal y軸ラベルの設定：「value」→「人口[千人]」 population %&gt;% filter(str_length(cat01_code) == 5) %&gt;% separate(`Ａ 人口・世帯`, c(&quot;code&quot;, &quot;年齢区分&quot;), sep = &quot;_&quot;) %&gt;% mutate(code = order(code, decreasing = TRUE)) %&gt;% mutate(年齢区分 = stringi::stri_trans_nfkc(年齢区分)) %&gt;% mutate(年齢区分 = str_remove(年齢区分, &quot;人口&quot;)) %&gt;% mutate(年齢区分 = fct_reorder(年齢区分, code)) %&gt;% mutate(調査年 = str_remove(調査年, &quot;年度&quot;)) %&gt;% mutate(調査年 = lubridate::ymd(調査年, truncated = 2)) %&gt;% mutate(value = value / 1000) %&gt;% ggplot(aes(調査年, value, fill = 年齢区分)) + geom_bar(stat = &quot;identity&quot;, alpha = 0.8) + theme_minimal(base_size = 16) + theme(legend.position = &quot;bottom&quot;) + scale_y_continuous(name = &quot;人口[千人]&quot;, labels = scales::comma) 続いて、65歳以上の人口と15歳未満の人口の比を取った「老年化指数」を計算し、折れ線グラフで指数の推移を可視化してみます。 population %&gt;% filter(str_length(cat01_code) == 5) %&gt;% select(-`Ａ 人口・世帯`) %&gt;% pivot_wider(names_from = cat01_code, values_from = value) %&gt;% mutate(老年化指数 = A1303 / A1301) %&gt;% mutate(調査年 = str_remove(調査年, &quot;年度&quot;)) %&gt;% mutate(調査年 = lubridate::ymd(調査年, truncated = 2)) %&gt;% ggplot(aes(調査年, 老年化指数)) + geom_area(alpha = 0.6) + geom_point(size = 2) + geom_line(size = 1) + theme_minimal(base_size = 16) + labs(title = &quot;老年化指数の推移&quot;, caption = &quot;出典：都道府県・市区町村のすがた（社会・人口統計体系）&quot;) "],["recycle.html", "8.3 【例2】リサイクル率の推移の可視化", " 8.3 【例2】リサイクル率の推移の可視化 ここでは、都道府県別のリサイクル率を可視化してみます。データベースから「リサイクル率」で検索すると「社会・人口統計体系」の「都道府県データ」がヒットしますので、これを用います。データIDは0000010108となります。 estat_getMetaInfo(appId, statsDataId = &quot;0000010108&quot;)$cat01 %&gt;% filter(str_detect(`@name`, &quot;リサイクル率&quot;)) ## # A tibble: 1 x 4 ## `@code` `@name` `@level` `@unit` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 H5614 H5614_ごみのリサイクル率 1 ％ rr &lt;- estat_getStatsData(appId, statsDataId = &quot;0000010108&quot;, cdCat01 = &quot;H5614&quot;) %&gt;% filter(地域 != &quot;全国&quot;) ## Fetching record 1-960... (total: 960 records) head(rr) ## # A tibble: 6 x 11 ## tab_code 観測値 cat01_code `Ｈ 居住` area_code 地域 time_code 調査年 unit ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 00001 観測値 H5614 H5614_ごみ~ 01000 北海~ 19991000~ 1999~ ％ ## 2 00001 観測値 H5614 H5614_ごみ~ 01000 北海~ 20001000~ 2000~ ％ ## 3 00001 観測値 H5614 H5614_ごみ~ 01000 北海~ 20011000~ 2001~ ％ ## 4 00001 観測値 H5614 H5614_ごみ~ 01000 北海~ 20021000~ 2002~ ％ ## 5 00001 観測値 H5614 H5614_ごみ~ 01000 北海~ 20031000~ 2003~ ％ ## 6 00001 観測値 H5614 H5614_ごみ~ 01000 北海~ 20041000~ 2004~ ％ ## # ... with 2 more variables: value &lt;dbl&gt;, annotation &lt;chr&gt; rr %&gt;% separate(調査年, &quot;year&quot;, sep = 4, convert = TRUE) %&gt;% ggplot(aes(year, value, group = 地域, color = 地域)) + geom_line() + theme_minimal() + labs(x = &quot;調査年&quot;, y = &quot;リサイクル率[%]&quot;, title = &quot;都道府県別リサイクル率の推移&quot;, caption = &quot;出典：都道府県・市区町村のすがた（社会・人口統計体系）&quot;) グラフから、全体としてリサイクル率が向上していることは分かりますが、線が多すぎて詳細がよく分かりません。プレゼンテーション用にグラフを加工してみます。グラフの表示方法でよく用いられるテクニックが「ハイライト」です。ここでは、最新の集計年での順位に基づき、1位と最下位、および福岡県をハイライトします。ggplot2のグラフでハイライトを行うには、gghighlightパッケージを用います。初めて使う場合は、インストールとセッション開始時のロードを行っておきます。 install.packages(&quot;gghighlight&quot;) library(gghighlight) gghighlightパッケージで利用できるgghighlight()関数でfilter()関数と同様の書式で、ハイライトしたいデータを抽出する式を記述することで、該当するデータのハイライトができるようになります。例えばmpgデータの場合に、midsizeのクラスだけハイライトするには以下のようにします。 ggplot(mpg, aes(class)) + geom_bar() + gghighlight(class == &quot;midsize&quot;, use_group_by = FALSE) ## label_key: class 2017年度のリサイクル率の順位に基づいてハイライトするため、2017年度のリサイクル率の順位を計算しておきます。 order2017 &lt;- filter(rr, 調査年 == &quot;2017年度&quot;) %&gt;% mutate(order = min_rank(value)) %&gt;% select(地域, order) head(order2017) ## # A tibble: 6 x 2 ## 地域 order ## &lt;chr&gt; &lt;int&gt; ## 1 北海道 42 ## 2 青森県 6 ## 3 岩手県 23 ## 4 宮城県 14 ## 5 秋田県 10 ## 6 山形県 5 これをリサイクル率のデータと結合して、リサイクル率が1位、47位および福岡県のデータをハイライトさせます。 rr %&gt;% left_join(order2017) %&gt;% separate(調査年, &quot;year&quot;, sep = 4, convert = TRUE) %&gt;% ggplot(aes(year, value, group = 地域, color = 地域)) + geom_line() + gghighlight(order %in% c(1, 47) | 地域 == &quot;福岡県&quot;, use_group_by = FALSE, label_params = list(direction = &quot;y&quot;)) + theme_minimal() + labs(x = &quot;調査年&quot;, y = &quot;リサイクル率[%]&quot;, title = &quot;都道府県別リサイクル率の推移&quot;, caption = &quot;出典：都道府県・市区町村のすがた（社会・人口統計体系）&quot;) ## Joining, by = &quot;地域&quot; ## label_key: 地域 "],["api02.html", "9 Webからのデータ取得（2）「World Bank API」", " 9 Webからのデータ取得（2）「World Bank API」 e-Statは日本の統計データを見る場合に利用しましたが、世界の国別の統計や指標を見たり比較したりする場合には世界銀行のウェブサイトが便利です。世界銀行のデータをAPI経由で取得するためのRのパッケージがwbstatsです。 使っているPCで初めて利用する場合は、 install.packages(&quot;remotes&quot;) remotes::install_github(&quot;nset-ornl/wbstats&quot;) でインストールしてください。セッションを立ち上げた後（プロジェクトを立ち上げた後）には、 library(wbstats) を実行してwbstatsの関数が利用できるようにしておきます。wb_cachelistは、利用可能な指標や国、トピックなどの一覧を保持しています。 str(wb_cachelist, max.level = 1) ## List of 8 ## $ countries : tibble [304 x 18] (S3: tbl_df/tbl/data.frame) ## $ indicators : tibble [16,649 x 8] (S3: tbl_df/tbl/data.frame) ## $ sources : tibble [63 x 9] (S3: tbl_df/tbl/data.frame) ## $ topics : tibble [21 x 3] (S3: tbl_df/tbl/data.frame) ## $ regions : tibble [48 x 4] (S3: tbl_df/tbl/data.frame) ## $ income_levels: tibble [7 x 3] (S3: tbl_df/tbl/data.frame) ## $ lending_types: tibble [4 x 3] (S3: tbl_df/tbl/data.frame) ## $ languages : tibble [23 x 3] (S3: tbl_df/tbl/data.frame) 利用可能な指標の一覧は以下のコマンドで確認できます。 View(wb_cachelist$indicators) indicator_id indicator unit indicator_desc source_org topics source_id source 1.0.HCount.1.90usd Poverty Headcount ($1.90 a day) NA The poverty headcount index measures the proportion of the population with daily per capita income (in 2011 PPP) below the poverty line. LAC Equity Lab tabulations of SEDLAC (CEDLAS and the World Bank). 11 , Poverty 37 LAC Equity Lab 1.0.HCount.2.5usd Poverty Headcount ($2.50 a day) NA The poverty headcount index measures the proportion of the population with daily per capita income (in 2005 PPP) below the poverty line. LAC Equity Lab tabulations of SEDLAC (CEDLAS and the World Bank). 11 , Poverty 37 LAC Equity Lab 1.0.HCount.Mid10to50 Middle Class ($10-50 a day) Headcount NA The poverty headcount index measures the proportion of the population with daily per capita income (in 2005 PPP) below the poverty line. LAC Equity Lab tabulations of SEDLAC (CEDLAS and the World Bank). 11 , Poverty 37 LAC Equity Lab 1.0.HCount.Ofcl Official Moderate Poverty Rate-National NA The poverty headcount index measures the proportion of the population with daily per capita income below the official poverty line developed by each country. LAC Equity Lab tabulations of data from National Statistical Offices. 11 , Poverty 37 LAC Equity Lab 1.0.HCount.Poor4uds Poverty Headcount ($4 a day) NA The poverty headcount index measures the proportion of the population with daily per capita income (in 2005 PPP) below the poverty line. LAC Equity Lab tabulations of SEDLAC (CEDLAS and the World Bank). 11 , Poverty 37 LAC Equity Lab 1.0.HCount.Vul4to10 Vulnerable ($4-10 a day) Headcount NA The poverty headcount index measures the proportion of the population with daily per capita income (in 2005 PPP) below the poverty line. LAC Equity Lab tabulations of SEDLAC (CEDLAS and the World Bank). 11 , Poverty 37 LAC Equity Lab データの検索はwb_search()関数を用います。 wb_search(&quot;forest area&quot;) ## # A tibble: 4 x 3 ## indicator_id indicator indicator_desc ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 AG.LND.FRST.~ Forest area (hectare~ Forest area is land under natural or plan~ ## 2 AG.LND.FRST.~ Forest area (sq. km) Forest area is land under natural or plan~ ## 3 AG.LND.FRST.~ Forest area (% of la~ Forest area is land under natural or plan~ ## 4 ER.FST.DFST.~ Annual deforestation~ Average annual deforestation refers to th~ 実際のデータの取得は、wb_data()関数を用います。indicator引数に取得したいデータのIDを指定します。 fa_data &lt;- wb_data(indicator = &quot;AG.LND.FRST.ZS&quot;, country = &quot;all&quot;) いくつかの国について、国土面積に対する森林面積の割合の推移を折れ線グラフとしてプロットしてみます。 fa_data %&gt;% filter(country %in% c(&quot;Japan&quot;, &quot;World&quot;, &quot;China&quot;, &quot;Latin America &amp; Caribbean&quot;)) %&gt;% mutate(date = lubridate::ymd(date, truncated = 2)) %&gt;% rename(value = 5) %&gt;% filter(!is.na(value)) %&gt;% ggplot(aes(date, value, group = country, color = country)) + geom_line() + theme_minimal(base_size = 16) + theme(legend.position = &quot;bottom&quot;) + labs(x = &quot;年&quot;, y = &quot;森林面積の割合[%]&quot;, title = &quot;国土面積に対する森林面積の割合の推移&quot;) + gghighlight(label_params = list(direction = &quot;y&quot;)) ## label_key: country 次に、日本のCO2排出量の推移を見てみましょう。 View(wb_search(&quot;CO2 emissions&quot;)) co2_data &lt;- wb_data(indicator = &quot;EN.ATM.CO2E.KT&quot;) head(co2_data) ## # A tibble: 6 x 9 ## iso2c iso3c country date EN.ATM.CO2E.KT unit obs_status footnote ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 AW ABW Aruba 1960 11093. &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 AW ABW Aruba 1961 11577. &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 3 AW ABW Aruba 1962 12713. &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 AW ABW Aruba 1963 12178. &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 5 AW ABW Aruba 1964 11841. &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 6 AW ABW Aruba 1965 10623. &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## # ... with 1 more variable: last_updated &lt;date&gt; co2_data %&gt;% filter(country == &quot;Japan&quot;) %&gt;% mutate(date = lubridate::ymd(date, truncated = 2)) %&gt;% rename(value = 5) %&gt;% filter(!is.na(value)) %&gt;% ggplot(aes(date, value)) + geom_area(alpha = 0.7) + theme_minimal(base_size = 16) + labs(x = &quot;年&quot;, y = &quot;CO2排出量[kt]&quot;, title = &quot;日本のCO2排出量の推移&quot;) "]]
