[
["dplyr-tidyr-01.html", "3 dplyr/tidyrを用いたデータの整理と変換(1)\n", " 3 dplyr/tidyrを用いたデータの整理と変換(1)\n"],
["package.html", "3.1 パッケージによる機能拡張", " 3.1 パッケージによる機能拡張 Rの特徴として、パッケージによって様々な機能を拡張できる点が挙げられます。パッケージのインストールには、install.packages()関数を用います。例えば、この後で利用するdplyrパッケージをインストールするには、以下のようにします。 install.packages(&quot;dplyr&quot;) パッケージのインストールは、Rを利用するPCで1度だけ実行しておけば十分です1。 パッケージで提供されている関数を利用する場合には、セッションごとにlibrary()関数を実行しておく必要があります。 library(dplyr) これを実行しない場合、関数をパッケージ名と共にdplyr::filter()のような形式で用いる必要があります。実行した場合は、単にfilter()とすれば利用できます。 ただし、dplyrパッケージは後述のtidyverseで合わせてインストールされますので、ここでは上記コマンドの実行は不要です。 定期的にアップデートは必要。Rのメジャーバージョン（例えば4.0.2の場合は“4”）が上がった場合は、インストールが必要）↩︎ "],
["tidyverse.html", "3.2 tidyverse", " 3.2 tidyverse tidyverseとは、tidy data（整然データ、整理データ）を軸としたデータサイエンスプロジェクトのためのパッケージ群です。tidyverseをインストールすると多くのパッケージがインストールされますが、主要なパッケージとしては以下のようなものになります。 dplyr : データの操作に関する一貫した文法を持つ関数を提供する ggplot2：Grammer of Graphics（グラフィックスの文法）に基づいて統計グラフを出力するための関数を提供する tidyr：tidy dataを得るために必要な関数を提供する readr：長方形のデータ（csv、tsvやfwfなど）を高速に読み込むための関数を提供する purr：Rにおける関数型プログラミング環境を提供する tibble：データフレームを拡張したクラスを提供する stringr：文字列処理を簡単に実行するための関数を提供する forcats：因子型を効率的に処理するための関数を提供する これらのパッケージが提供する関数は library(tidyverse) とすることで、一括して直接利用できるようになります。 "],
["nycflights13.html", "3.3 nycflights13", " 3.3 nycflights13 ここでは、nycflights13パッケージで提供されているflightsデータを利用して各種機能の解説や演習を行っていきます。パッケージのインストールは以下のように行います。 install.packages(&quot;nycflights13&quot;) データを利用するには library(nycflights13) としておきます。 flightsにデータが格納されています。flightsデータは、データフレームを拡張したtibbleという形式となっていますが、ほとんどの場合データフレームと同じ扱い方で問題ありません2。データフレームの場合、以下のようにオブジェクトの中身を出力するとすべてが出力されますが、tibbleの場合、最初の10行のみと、コンソールに入る列数分の変数が表示され、データの下に残りの行数と変数の数と変数名と変数の型が表示されます。 flights ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # ... with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; flightsデータには、2013年にニューヨークの各空港を離陸したすべてのフライトに関する情報が記録されています。変数の一覧を表に示します。 列名 内容 列名 内容 year 年 tailnum 機体番号 month 月 flight 便名 day 日 origin 出発地 dep_time 離陸時刻 dest 到着地 dep_delay 離陸遅延時間[分] air_time 飛行時間[分] arr_time 到着時刻 distance 飛行距離 arr_delay 到着遅延時間[分] hour 離陸時刻[時] carrier 航空会社省略名 minute 離陸時刻[分] time_hour 出発予定時刻 そうでない場合も一部あります。↩︎ "],
["onetable-verbs.html", "3.4 1つのテーブルに対するverb", " 3.4 1つのテーブルに対するverb dplyrパッケージはデータの操作に関する一貫した文法を持つ関数を提供しています。このパッケージにおいて、テーブル（データフレームやtibbleなど）に対して何らかの処理を行う関数のことをverbと呼びます。verbは以下のようなルールで用いられます。 最初の引数は処理対象となるテーブル 2番目以降の引数で、verbに関連するオプションを指定 帰ってくる値は常にテーブル verbの説明のために、以下のように簡単なデータフレームを作成しておきます。 df &lt;- data.frame( color = c(&quot;blue&quot;, &quot;black&quot;, &quot;blue&quot;, &quot;blue&quot;, &quot;black&quot;), value = 1:5 ) df ## color value ## 1 blue 1 ## 2 black 2 ## 3 blue 3 ## 4 blue 4 ## 5 black 5 3.4.1 値の条件による抽出：filter() filter()関数は第2引数以降で指定した条件に合致する行のみを抽出するためのverbです。以下のようにすると、変数colorが\"blue\"である行のみが抽出されます。 filter(df, color == &quot;blue&quot;) ## color value ## 1 blue 1 ## 2 blue 3 ## 3 blue 4 「等しい」という表現は、==となることに注意してください。変数valueが1もしくは4の行のみ抽出する場合は filter(df, value %in% c(1, 4)) ## color value ## 1 blue 1 ## 2 blue 4 のようにします。条件部には以下のような、条件演算子を用いた条件式を記述します。 演算子 機能 演算子 機能 x &gt; 1 1より大きい x != 1 1と等しくない x &gt;= 1 1以上 x == 1 1と等しい x &lt; 1 1より小さい x %in% c(1, 2) 1か2のいずれか x &lt;= 1 1以下 また、複数の条件を用いる場合は、以下のような論理演算子を用います。 式 機能 a | b 条件aと条件bのいずれかを満たす（論理和） a &amp; b 条件aと条件bの両方を満たす（論理積） !a 条件aを満たさない（否定） xor(a, b) 条件aと条件bの排他的論理和 colorが\"blue\"でvalueが3未満の行のみを抽出するには以下のようにします。 filter(df, color == &quot;blue&quot; &amp; value &lt;= 3) ## color value ## 1 blue 1 ## 2 blue 3 3.4.2 指定した列の抽出：select() #{select} select()関数は第2引数以降で指定した列を抽出するためのverbです。dfから変数colorのみ、もしくはcolor以外の変数を抽出するには次のようにします。 select(df, color) ## color ## 1 blue ## 2 black ## 3 blue ## 4 blue ## 5 black select(df, -color) ## value ## 1 1 ## 2 2 ## 3 3 ## 4 4 ## 5 5 3.4.3 指定した列を昇順でソート：arrange() #{arrange} arrange()は、第2引数以降で指定した列について、昇順でソートするためのverbです。colorの列について、昇順でソートするには arrange(df, color) ## color value ## 1 black 2 ## 2 black 5 ## 3 blue 1 ## 4 blue 3 ## 5 blue 4 とします。colorの列は文字列であるため、アルファベット順に並びます。valueの列を降順にソートするためにはdesc()関数を用いて arrange(df, desc(value)) ## color value ## 1 black 5 ## 2 blue 4 ## 3 blue 3 ## 4 black 2 ## 5 blue 1 とします。 3.4.4 新しい列の作成：mutate() 新しい列を作成して、他の列に対する演算結果等を格納する場合には、mutate()を用います。dfのvalue列の各値を2倍した結果を新たに作成したdouble列に格納するには、以下のようにします。 mutate(df, double = 2*value) ## color value double ## 1 blue 1 2 ## 2 black 2 4 ## 3 blue 3 6 ## 4 blue 4 8 ## 5 black 5 10 第2引数で定義した変数を、第3引数以降での演算に利用できます。 mutate(df, double = 2*value, quadruple = 2*double) ## color value double quadruple ## 1 blue 1 2 4 ## 2 black 2 4 8 ## 3 blue 3 6 12 ## 4 blue 4 8 16 ## 5 black 5 10 20 3.4.5 グループごとの要約：group_by()とsummarise() グループごとに平均値や中央値などの要約を計算したい場合には、group_by()とsummarise()を組み合わせて用います。全体の要約を行う場合には、summarise()のみを用いることもあります。例えば、dfのvalueの合計を求めるには以下のようにします。 summarise(df, total = sum(value), .groups = &quot;drop&quot;) ## total ## 1 15 第3引数の.groups = \"drop\"は、要約後にグループ化の情報を残すかどうかの設定となります。特に必要が無ければ\"drop\"を指定しておくとよいでしょう。 colorごとに合計を求めるには、group_by()でグループ化を行ってから、summarise()で要約を行います。group_by()を実行することで、テーブルにグループ化された変数についての情報が付加されます。 by_color &lt;- group_by(df, color) by_color ## # A tibble: 5 x 2 ## # Groups: color [2] ## color value ## &lt;chr&gt; &lt;int&gt; ## 1 blue 1 ## 2 black 2 ## 3 blue 3 ## 4 blue 4 ## 5 black 5 この出力は、color列に2つのグループが設定されていることを示しています。この結果に対してsummarise()を適用すれば、グループごとの要約ができます。 summarise(by_color, total = sum(value), .groups = &quot;drop&quot;) ## # A tibble: 2 x 2 ## color total ## &lt;chr&gt; &lt;int&gt; ## 1 black 7 ## 2 blue 8 複数の列の値の組み合わせでグループ分けを行う場合には、それらの列名をgroup_by()の第2引数以降に並べます。 by_date &lt;- group_by(flights, year, month, day) by_date ## # A tibble: 336,776 x 19 ## # Groups: year, month, day [365] ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # ... with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 要約のための関数には以下のようなものがあります。 関数 説明 min(x), max(x) xの最大値、最小値 median(x) xの中央値 n() グループごとの件数 n_distinct() グループごとのユニークな行数 sum(x), mean(x) xの合計、平均値 sum(x &gt; 10) x &gt; 10を満たす行数 mean(x &gt; 10) x &gt; 10を満たす比率 sd(x), var(x) xの標準偏差、分散 "],
["pipe.html", "3.5 パイプ", " 3.5 パイプ 以下のように、複数のverbを続けて実行すると、可読性が悪くなります。どのような処理をしているのでしょうか。 hourly_delay &lt;- filter( summarise( group_by( filter( flights, !is.na(dep_delay) ), year, month, day, hour ), delay = mean(dep_delay), n = n(), .groups = &quot;drop&quot; ), n &gt; 10 ) magrittrパッケージ（dplyrが入っていればインストールされている）で提供されているパイプ演算子を用いると、このような処理を簡潔に記述できる。一般に、ある関数f()をオブジェクトxに引数yを伴って適用する場合、 x %&gt;% f(y) と記述すれば f(x, y) を実行したことになります。パイプはいくつも続けて適用することができるため、上の処理は hourly_delay &lt;- flights %&gt;% filter(!is.na(dep_delay)) %&gt;% group_by(year, month, day, hour) %&gt;% summarise(delay = mean(dep_delay), n = n(), .groups = &quot;drop&quot;) %&gt;% filter(n &gt; 10) hourly_delay ## # A tibble: 5,813 x 6 ## year month day hour delay n ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 6 2.16 51 ## 2 2013 1 1 7 3.51 49 ## 3 2013 1 1 8 0.448 58 ## 4 2013 1 1 9 5.34 56 ## 5 2013 1 1 10 0.333 39 ## 6 2013 1 1 11 3.19 37 ## 7 2013 1 1 12 5.75 56 ## 8 2013 1 1 13 20.4 54 ## 9 2013 1 1 14 17.2 48 ## 10 2013 1 1 15 7.77 66 ## # ... with 5,803 more rows のように記述できます。 "]
]
