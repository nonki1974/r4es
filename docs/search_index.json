[["dplyr-tidyr-03.html", "5 dplyr/tidyrを用いたデータの整理と変換(3) ", " 5 dplyr/tidyrを用いたデータの整理と変換(3) "],["tidydata.html", "5.1 tidydataとは？", " 5.1 tidydataとは？ 以下の原則を満たすデータを、tidydataと呼びます。 各変数には専用の列がある 各観測には専用の行がある 各値は専用のセルにある データはさまざまな形で提供されますが、tidydataの形式に変換することで、分析や可視化がスムーズに行えるようになります。tidyverseに含まれるパッケージ群は、tidydataを前提とした関数を提供しています。その中でも、tidyでないデータをtidydataに変換する関数を提供するパッケージがtidyrパッケージです。 例えば、以下のようなデータはtidydataです。 table1 &lt;- tibble( country = c(&quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Brazil&quot;, &quot;Brazil&quot;, &quot;China&quot;, &quot;China&quot;), year = rep(c(1999L, 2000L), 3), cases = c(745L, 2666L, 37737L, 80488L, 212258L, 213766L), population = c(19987071L, 20595360L, 172006362L, 174504898L, 1272915272L, 1280428583L) ) country year cases population Afghanistan 1999 745 19987071 Afghanistan 2000 2666 20595360 Brazil 1999 37737 172006362 Brazil 2000 80488 174504898 China 1999 212258 1272915272 China 2000 213766 1280428583 以下のデータは、casesとpopulationの値がcountに混在しており、それぞれが専用の列をもたない形になっているため、tidydataではありません。 table2 &lt;- table1 %&gt;% pivot_longer(c(cases, population), names_to = &quot;key&quot;, values_to = &quot;value&quot;) %&gt;% arrange(country, year) country year key value Afghanistan 1999 cases 745 Afghanistan 1999 population 19987071 Afghanistan 2000 cases 2666 Afghanistan 2000 population 20595360 Brazil 1999 cases 37737 Brazil 1999 population 172006362 Brazil 2000 cases 80488 Brazil 2000 population 174504898 China 1999 cases 212258 China 1999 population 1272915272 China 2000 cases 213766 China 2000 population 1280428583 以下のデータは、rateの列におけるそれぞれのセルに複数の値が含まれているため、tidydataではありません。 table3 &lt;- table1 %&gt;% unite(rate, cases, population, sep = &quot;/&quot;) country year rate Afghanistan 1999 745/19987071 Afghanistan 2000 2666/20595360 Brazil 1999 37737/172006362 Brazil 2000 80488/174504898 China 1999 212258/1272915272 China 2000 213766/1280428583 以下のデータは、2つのテーブルにデータがまたがっているため、tidydataではありません。 table4a &lt;- table1 %&gt;% select(-population) %&gt;% pivot_wider(names_from = year, values_from = cases) country 1999 2000 Afghanistan 745 2666 Brazil 37737 80488 China 212258 213766 table4b &lt;- table1 %&gt;% select(-cases) %&gt;% pivot_wider(names_from = year, values_from = population) country 1999 2000 Afghanistan 19987071 20595360 Brazil 172006362 174504898 China 1272915272 1280428583 "],["long-wide.html", "5.2 縦長（long）データと横長（wide）データの相互変換", " 5.2 縦長（long）データと横長（wide）データの相互変換 5.2.1 pivot_longer()関数を用いたwideからlongへの変換 table4aやtable4bは、列名が1999や2000というように「年」に関する変数の観測値となっています。また、テーブル内部の数値は、table4aの場合casesの観測値、table4bの場合はpopulationの観測値というように、単一の変数の観測値が複数列にまたがっています。このような形のテーブルとなっているデータのことを横長（wide型）データと呼びます。 knitr::kable(table4a) country 1999 2000 Afghanistan 745 2666 Brazil 37737 80488 China 212258 213766 このデータを、year列に「年」の観測値（1999もしくは2000）、cases列にcasesの観測値を格納する形式、すなわち縦長（long型）データに変換するには、pivot_longer()関数を用います。 pivot_longer()関数の第1引数はdplyrのverbと同様にデータフレームとなります。また、関数を適用した結果もデータフレームになりますので、パイプ処理の中で利用できます。第2引数に、観測値が列名となっている列の一覧をdplyrのselect()関数で変数を選択する場合と同様の形式（ただし、複数の変数の列挙はc()関数を使う）で与えます。また、それらに対する新たに設定する変数名をnames_to引数に文字列として指定し、それらの値に対して新たに設定する変数名をvalues_to引数に文字列として指定します。table4aに対しては、例えば以下のようにします。 table4a %&gt;% pivot_longer(-country, names_to = &quot;year&quot;, values_to = &quot;cases&quot;) ## # A tibble: 6 x 3 ## country year cases ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 2000 2666 ## 3 Brazil 1999 37737 ## 4 Brazil 2000 80488 ## 5 China 1999 212258 ## 6 China 2000 213766 観測値が列名となっている列の一覧は、c(1999,2000)のような形式でもいいですが、ここではcountry以外のすべての列ということで、-countryとしています。また、names_toとvalues_toは、新たに設定する変数名であり、table4aに含まれる列名ではありませんので、ダブルクォートをつけて文字列として指定する必要があります。 5.2.2 pivot_wider()関数を用いたwideからlongへの変換 table2は1つの観測（各国の1年分の観測）が2行にまたがっています。これはtidydataの1行が1観測という原則を満たしておらず、tidydataではありません。これをtidydataにするためには、count列を広げてkey列の値を変数名とした新たな列を作成する必要があります。 knitr::kable(table2) country year key value Afghanistan 1999 cases 745 Afghanistan 1999 population 19987071 Afghanistan 2000 cases 2666 Afghanistan 2000 population 20595360 Brazil 1999 cases 37737 Brazil 1999 population 172006362 Brazil 2000 cases 80488 Brazil 2000 population 174504898 China 1999 cases 212258 China 1999 population 1272915272 China 2000 cases 213766 China 2000 population 1280428583 これは、前のセクションにおけるpivot_longer()と逆の操作に相当し、long形式からwide形式への変換となります。これを行うのがpivot_wider()関数です。 pivot_wider()関数もpivot_longer()関数と同様にパイプ処理の中で利用できます。names_from引数に変数名を含む列（ここではkey）、values_from引数にそれらの変数名に対応した値が格納されている列（ここではcount）を指定します。これらは、データフレーム内の変数名ですので、ダブルクォートはつけません。table2に対しては例えば以下のようにします。 table2 %&gt;% pivot_wider(names_from = key, values_from = value) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 "],["unite-and-separate.html", "5.3 列の分割と結合", " 5.3 列の分割と結合 table3はrateの列に複数の変数（populationとcases）の情報が文字列として格納されており、tidyではありません。このようにひとつの列に含まれている文字列を、複数の列に分割したい場合は、separate()関数を用います。separate()関数は、dplyrのverbと同様に、第1引数はデータフレームで、出力もデータフレームです。第1引数以外で必要な引数としては，分割元の変数を指定するcolと分割した後に設定する変数名のベクトルintoとなります。table3の場合、colにrate、intoにc(\"cases\", \"population\")を指定します。 table3 ## # A tibble: 6 x 3 ## country year rate ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 table3 %&gt;% separate(rate, c(&quot;cases&quot;, &quot;population&quot;)) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 これでもOKですが、分割された後の変数が文字列になっているので、数字のみの文字列であれば、convert引数をTRUEに設定すると、数値に変換してくれます。 table3 %&gt;% separate(rate, c(&quot;cases&quot;, &quot;population&quot;), convert = TRUE) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 また、区切り文字については、デフォルトでは数値以外の文字となっていますが、指定したい場合は、sep引数を指定します。（table3の場合は指定しなくてもOKです。） table3 %&gt;% separate(rate, c(&quot;cases&quot;, &quot;population&quot;), sep = &quot;/&quot;) separate()関数とは反対に、複数の変数をひとつの列に結合したい場合は、unite()関数を用います。ここでは、unite()関数の動作確認のために、table3のyearを先頭2桁のcenturyと後ろ2桁のyearに分割をしてから、再度結合することを考えます。sep引数に数値を与えると、その数値の桁数分で分割されます。 table5 &lt;- table3 %&gt;% separate(year, c(&quot;century&quot;, &quot;year&quot;, sep = 2)) ## Warning: Expected 3 pieces. Missing pieces filled with `NA` in 6 rows [1, 2, 3, ## 4, 5, 6]. table5 ## # A tibble: 6 x 5 ## country century year `2` rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 &lt;NA&gt; &lt;NA&gt; 745/19987071 ## 2 Afghanistan 2000 &lt;NA&gt; &lt;NA&gt; 2666/20595360 ## 3 Brazil 1999 &lt;NA&gt; &lt;NA&gt; 37737/172006362 ## 4 Brazil 2000 &lt;NA&gt; &lt;NA&gt; 80488/174504898 ## 5 China 1999 &lt;NA&gt; &lt;NA&gt; 212258/1272915272 ## 6 China 2000 &lt;NA&gt; &lt;NA&gt; 213766/1280428583 centuryとyearの列をunite()関数で結合して、改めてyear列とします。unite()関数もdplyrのverbと同様に、第1引数はデータフレームで、出力もデータフレームです。第1引数以外で必要な引数としては，結合後の変数名colと、select()と同様に指定された結合対象の変数名となります。 table5 %&gt;% unite(col = new, century, year) ## # A tibble: 6 x 4 ## country new `2` rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999_NA &lt;NA&gt; 745/19987071 ## 2 Afghanistan 2000_NA &lt;NA&gt; 2666/20595360 ## 3 Brazil 1999_NA &lt;NA&gt; 37737/172006362 ## 4 Brazil 2000_NA &lt;NA&gt; 80488/174504898 ## 5 China 1999_NA &lt;NA&gt; 212258/1272915272 ## 6 China 2000_NA &lt;NA&gt; 213766/1280428583 このように、デフォルトではアンダースコア_によって結合されますが、結合文字を指定したい場合はsep変数を指定します（以下の例は空の文字列）。 table5 %&gt;% unite(col = new, century, year, sep = &quot;&quot;) ## # A tibble: 6 x 4 ## country new `2` rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999NA &lt;NA&gt; 745/19987071 ## 2 Afghanistan 2000NA &lt;NA&gt; 2666/20595360 ## 3 Brazil 1999NA &lt;NA&gt; 37737/172006362 ## 4 Brazil 2000NA &lt;NA&gt; 80488/174504898 ## 5 China 1999NA &lt;NA&gt; 212258/1272915272 ## 6 China 2000NA &lt;NA&gt; 213766/1280428583 "]]
