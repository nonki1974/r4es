[
["index.html", "Rによるデータ解析入門 1 Rの基礎（データ構造とデータ型）", " Rによるデータ解析入門 Tomokazu FUJINO (@nonki1974) 1 Rの基礎（データ構造とデータ型） ここでは、データは数値や文字の集まりであると考えます。Rで標準的に利用できるデータの格納方法（データ構造）は以下の4つです。 ベクトル（vector） 配列・行列（array, matrix） リスト（list） データフレーム（data frame） 一方、個々のデータそのものの種類をデータ型と呼び、Rでは主に以下の3つを利用します。 数値型（numeric） 文字型（charater） 因子型（factor） 特に、因子型は他のプログラミング言語にはないデータ型で、統計解析環境であるRならではのデータ型となっています。 "],
["vector.html", "1.1 データ構造（1）ベクトル", " 1.1 データ構造（1）ベクトル Rにおける最もシンプルなデータ構造がベクトルです。Rにおいては、単一の数値であっても、大きさ1のベクトルとして扱われます。例えば、以下のような演算を実行した結果の数値も大きさ1のベクトルです。結果に表示される[1]はそのすぐ右にある数値がベクトルの1番目の要素であることを示しています。 3+4 ## [1] 7 sqrt(9) ## [1] 3 sin(pi/6) ## [1] 0.5 多くの要素を持つベクトルの場合、例えば正規乱数を12個生成した結果のベクトルは以下のように表示されます。 rnorm(12) ## [1] 1.19368051 1.28468691 0.71355066 -0.44422078 1.17302946 -0.56029953 ## [7] 1.00513850 0.13807508 -0.01270463 0.21210304 -2.18348449 0.64343219 1.1.1 オブジェクトと変数 Rのコンソールにコマンドを入力すると、Rは何らかの結果をベクトルなどの形で出力してくれます。これらを総称してオブジェクトと呼びます。上のようなコマンドでは出力された結果のオブジェクトは再利用できませんが、変数に代入することで、再利用することができます。例えば、 x &lt;- rnorm(12) とすると、実行結果には何も表示されませんが、変数xの中に実行結果が格納されます。&lt;-（代入演算子と呼びます）は、左辺の変数に右辺の実行結果を代入しなさいという意味になります。つまり、xにrnorm(12)の結果のオブジェクトが格納されたということになります。xの中に何が入っているかを知りたい場合は、コンソールにxと入力します。 x ## [1] -0.95322691 -0.26106511 -0.10800208 -0.78278523 -1.01377640 -1.95843312 ## [7] 0.09200195 0.59526261 -1.21415081 1.89372942 -2.09527661 0.82363148 変数名には、文字、数字、ピリオドなどの記号が利用できますが先頭に数字がつくものは使えません。また、大文字と小文字を区別しますので、注意しましょう。実際に分析するときは、分析者にとって分かりやすく、また複数の分析者で分析する場合は他の人が見てもある程度推測できるような変数名にするとよいです。 student_id &lt;- 1200 任意のベクトルを作成する場合は、c()関数1を用います。 x &lt;- c(3, 6, 10) x ## [1] 3 6 10 y &lt;- c(sin(pi/6), sqrt(9)) y ## [1] 0.5 3.0 1.1.2 便利なベクトル作成法 規則的に並んだ数値を要素とするベクトルを作成するには、いくつかの便利な方法があります。 # 1ずつ増加する数列 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 # 同じ数値の繰り返し rep(10, 5) ## [1] 10 10 10 10 10 # 増分を指定した数列（任意の公差をもつ等差数列） seq(1, 2, 0.1) ## [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 1.1.3 ベクトルの演算 ベクトル同士の演算は、2つのベクトルの大きさが同じ場合には要素同士の演算結果がベクトルとして返されます。 x &lt;- c(3, 6, 10) y &lt;- c(3, 2, 5) x + y ## [1] 6 8 15 x - y ## [1] 0 4 5 x * y ## [1] 9 12 50 x / y ## [1] 1 3 2 2つのベクトルの大きさが異なる場合には、小さい方のベクトルの要素が、大きい方と同じ大きさになるまで「リサイクル」されます。以下のコマンドはx^c(2, 2, 2)と同じであると理解しましょう。 x^2 ## [1] 9 36 100 以下のように、大きい方のベクトルの大きさが、小さい方の大きさの定数倍でない場合には警告が出力されます。 z &lt;- c(1, 2) x * z ## Warning in x * z: 長いオブジェクトの長さが短いオブジェクトの長さの倍数になってい ## ません ## [1] 3 12 10 1.1.4 ベクトルの要素の参照 ベクトルの要素を参照する場合は、[]を以下のように使います。 x[2] ## [1] 6 x[2:3] ## [1] 6 10 x[c(1, 3)] ## [1] 3 10 1.1.5 ベクトルに対する便利な関数 複数の処理をまとめたものを関数（function）といいます。関数にはRに元々組み込まれているものもありますし、自分で関数を作ることもできます。関数は 関数名() の形式で呼び出すことができ、()内にオブジェクトを記述することで、関数はそのオブジェクトに対して定められた処理を実行します。()内に記述するオブジェクトを引数（ひきすう）と呼びます。 ベクトルに対しては、以下のような関数がよく用いられます。 # ベクトルの大きさ（要素数）を出力する length(x) ## [1] 3 # 数値ベクトルの合計を出力する sum(x) ## [1] 19 # 数値ベクトルの平均を出力する mean(x) ## [1] 6.333333 # 数値ベクトルの標準偏差（standard deviation）を出力する sd(x) ## [1] 3.511885 cはcombineのcを意味している↩︎ "],
["datatype.html", "1.2 データ型", " 1.2 データ型 1.2.1 数値型と文字型 これまで扱ってきたベクトルに格納しているデータはすべて数値型（numeric）でした。Rでは文字列もデータとして扱うことができ、文字型（character）のデータと呼びます。文字型のデータはダブルクォート\"で囲むことによって表現します。 s &lt;- c(&quot;Kasumi&quot;, &quot;Nadeshiko&quot;, &quot;Kashii&quot;) s ## [1] &quot;Kasumi&quot; &quot;Nadeshiko&quot; &quot;Kashii&quot; ベクトルは、異なるデータ型を混在させることはできません。数値型と文字型が混在したベクトルを作成しようとすると、数値型が文字型に強制変換されます。 c(&quot;Happy&quot;, &quot;New&quot;, &quot;Year&quot;, 2021) ## [1] &quot;Happy&quot; &quot;New&quot; &quot;Year&quot; &quot;2021&quot; class()関数によってオブジェクトの型を確認することができます。 class(x) ## [1] &quot;numeric&quot; class(s) ## [1] &quot;character&quot; 1.2.2 因子型 統計データを扱うR言語独特のデータ型として、因子型（factor）があります。統計学においては、データをその性質から 名義尺度：分類コードやIDとして用いられる数値（血液型や性別など） 順序尺度：名義尺度に順序に関する情報が追加された数値（成績など） 間隔尺度：差の演算結果に意味がある数値（摂氏の気温など） 比例尺度：比の演算結果に意味がある数値（長さ重さなど、0が何もないを表すもの） の4種類に分類するという考え方が一般的です。名義尺度と順序尺度の値を持つ変数のことを質的変数と呼び、因子型は質的変数を扱うためのデータ型となっています。 # 数値型から因子型ベクトルを作成 hakata &lt;- c(0, 2, 3, 1, 3, 2, 1, 2) fhakata &lt;- factor(hakata, levels = 0:3) fhakata ## [1] 0 2 3 1 3 2 1 2 ## Levels: 0 1 2 3 as.numeric(fhakata) ## [1] 1 3 4 2 4 3 2 3 as.numeric(as.character(fhakata)) ## [1] 0 2 3 1 3 2 1 2 この例では、最初に数値型のベクトルを作成し、それをfactor()関数で因子型のベクトルに変換しています。factor()関数のlevels引数は、水準集合のベクトルを指定します。この場合、0という数値が1番目の水準に、1という数値が2番目の水準というように割り当てられることを意味します。 因子型のベクトルの場合、内容を表示するとLevelsの行のように水準集合が合わせて表示されるので、これでデータが因子型かどうかを見分けることができます。as.numeric()関数で因子型ベクトルを数値型ベクトルに変換すると、水準番号が出力されます。元のデータを出力する場合には、as.character()関数で一旦文字型ベクトルに変換してから、数値型ベクトルに変換します。 levels関数を使うと、水準集合を参照したり更新したりすることができます。 levels(fhakata) ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; levels(fhakata) &lt;- c(&quot;天ぷら&quot;, &quot;もつ鍋&quot;, &quot;ラーメン&quot;, &quot;ごまさば&quot;) fhakata ## [1] 天ぷら ラーメン ごまさば もつ鍋 ごまさば ラーメン もつ鍋 ラーメン ## Levels: 天ぷら もつ鍋 ラーメン ごまさば as.numeric(fhakata) ## [1] 1 3 4 2 4 3 2 3 質的変数のデータは、元々は文字列として記録されていることが多いかもしれません。文字型ベクトルをfactor()関数で因子型に変換すると、出現した要素全てが水準集合に含まれるようになります。 fhakata_char &lt;- c(&quot;天ぷら&quot;, &quot;もつ鍋&quot;, &quot;ラーメン&quot;, &quot;ごまさば&quot;, &quot;ラーメン&quot;) factor(fhakata_char) ## [1] 天ぷら もつ鍋 ラーメン ごまさば ラーメン ## Levels: ごまさば もつ鍋 ラーメン 天ぷら 1.2.3 論理型 TRUEとFALSEあるいはそれらの省略形としてTとFは、論理型（logical）と呼ばれるデータ型の値であり、それぞれ真（True）と偽（False）を表現するために用いられます2。 logical_sample &lt;- c(TRUE, FALSE, T, T, F, F) logical_sample ## [1] TRUE FALSE TRUE TRUE FALSE FALSE 1.2.4 欠損値の表現について 実際に統計データを扱う際には、何らかの理由で一部のデータが観測されなかったり、個人情報保護の目的で一部のデータが提供されていなかったりすることがあります。このようなデータを表現するために、Rでは欠損値を意味する値NAが用いられます。 x &lt;- c(2, 5, 10, NA, 3, 2) x ## [1] 2 5 10 NA 3 2 NAを含んだベクトルに対して演算や集計をした場合は次のようになります。 y &lt;- 1:6 x + y ## [1] 3 7 13 NA 8 8 sum(x) ## [1] NA mean(x) ## [1] NA sum()関数やmean()関数で欠損値を無視して計算したい場合には、引数でna.rm = TRUEを指定します。 sum(x, na.rm = TRUE) ## [1] 22 mean(x, na.rm = TRUE) ## [1] 4.4 因子型ベクトルを作成するとき、数値型のベクトルに水準集合に含まれない要素がある場合には、因子型ベクトルの中では欠損値として扱われます。 factor(c(2, 3, 5, 2), levels = 1:4) ## [1] 2 3 &lt;NA&gt; 2 ## Levels: 1 2 3 4 ダブルクォートがついていないので文字型ではないことに注意↩︎ "],
["arrayandmatrix.html", "1.3 データ構造（2）配列と行列", " 1.3 データ構造（2）配列と行列 ベクトルに次元属性を与えることにより、配列として扱えるようになります。 x &lt;- 1:9 x ## [1] 1 2 3 4 5 6 7 8 9 # xを3x3の2次元配列（行列）として扱う dim(x) &lt;- c(3, 3) x ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 x3 &lt;- 1:27 # x3を3x3x3の3次元配列として扱う dim(x3) &lt;- c(3, 3, 3) x3 ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 10 13 16 ## [2,] 11 14 17 ## [3,] 12 15 18 ## ## , , 3 ## ## [,1] [,2] [,3] ## [1,] 19 22 25 ## [2,] 20 23 26 ## [3,] 21 24 27 dim()関数により次元属性が与えられ、引数には各次元の要素数を指定します。配列の各要素は、各次元の要素番号を指定しても、ベクトルとしての要素番号を指定しても参照できます。 x3[1, 2, 1] ## [1] 4 x3[4] ## [1] 4 特に2次元配列である行列を作成する場合には、matrix()関数を使うことができます。 matrix(1:15, ncol = 5, byrow = TRUE) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 ## [3,] 11 12 13 14 15 最初の引数でベクトルを指定しますncolは行列の列数、byrowは行方向にベクトルの要素を並べるかどうかをTRUEかFALSEで指定します（デフォルトはFALSE）。 "],
["list.html", "1.4 データ構造（3）リスト", " 1.4 データ構造（3）リスト ベクトルは単一のデータ型しか保持できませんが、異なるデータ型のベクトルの集まりを1つのオブジェクトとして扱えるデータ構造をリストといいます。リストは、ベクトルだけでなく、別のリストも要素として持つことができます。 season &lt;- 2013 pacific &lt;- c(&quot;楽天&quot;, &quot;西武&quot;, &quot;ロッテ&quot;, &quot;ソフトバンク&quot;, &quot;オリックス&quot;, &quot;日本ハム&quot;) central &lt;- c(&quot;巨人&quot;, &quot;阪神&quot;, &quot;広島&quot;, &quot;中日&quot;, &quot;DeNA&quot;, &quot;ヤクルト&quot;) npb &lt;- list(pacific = pacific, central = central, season = season) npb ## $pacific ## [1] &quot;楽天&quot; &quot;西武&quot; &quot;ロッテ&quot; &quot;ソフトバンク&quot; &quot;オリックス&quot; ## [6] &quot;日本ハム&quot; ## ## $central ## [1] &quot;巨人&quot; &quot;阪神&quot; &quot;広島&quot; &quot;中日&quot; &quot;DeNA&quot; &quot;ヤクルト&quot; ## ## $season ## [1] 2013 リストを新たに作成するにはlist()関数を用います。引数は、要素の参照名 = オブジェクトをカンマ区切りで列挙します。リストのオブジェクト名の後に$要素の参照名をつけて実行すると、指定したリストの要素を直接参照できます。例えば、 npb$pacific ## [1] &quot;楽天&quot; &quot;西武&quot; &quot;ロッテ&quot; &quot;ソフトバンク&quot; &quot;オリックス&quot; ## [6] &quot;日本ハム&quot; また、npb[[1]]のようにすれば、要素番号でリストの要素を参照することもできます。 npb[[2]] ## [1] &quot;巨人&quot; &quot;阪神&quot; &quot;広島&quot; &quot;中日&quot; &quot;DeNA&quot; &quot;ヤクルト&quot; 以下のようにして、文字列として参照名を指定することもできますが、この場合の結果はリストとなります。 npb[&quot;central&quot;] ## $central ## [1] &quot;巨人&quot; &quot;阪神&quot; &quot;広島&quot; &quot;中日&quot; &quot;DeNA&quot; &quot;ヤクルト&quot; class(npb[&quot;central&quot;]) ## [1] &quot;list&quot; 統計計算などを行うRの関数の多くは、その結果をリストの形式で返します。リストの要素の参照名の一覧を見るにはnames()関数を用います。 names(npb) ## [1] &quot;pacific&quot; &quot;central&quot; &quot;season&quot; また、リストの構造を見たい場合は、str()関数を用います。 str(npb) ## List of 3 ## $ pacific: chr [1:6] &quot;楽天&quot; &quot;西武&quot; &quot;ロッテ&quot; &quot;ソフトバンク&quot; ... ## $ central: chr [1:6] &quot;巨人&quot; &quot;阪神&quot; &quot;広島&quot; &quot;中日&quot; ... ## $ season : num 2013 "],
["dataframe.html", "1.5 データ構造（4）データフレーム", " 1.5 データ構造（4）データフレーム データフレームは、同じ長さの複数のベクトルを要素とするリストで、表形式のデータを扱うためのデータ構造です。行列と違い、各列のデータ型は異なっても構いません。データフレームの各行を個体、各列を変数と呼びます。データフレームを作成するには、data.frame()関数を用います。引数はlist()関数と同様です。 pacific_seiseki &lt;- data.frame(pacific = pacific, win = c(82, 74, 74, 73, 66, 64), lose = c(59, 66, 68, 69, 73, 78)) pacific_seiseki ## pacific win lose ## 1 楽天 82 59 ## 2 西武 74 66 ## 3 ロッテ 74 68 ## 4 ソフトバンク 73 69 ## 5 オリックス 66 73 ## 6 日本ハム 64 78 リストと同様に、データフレームの列を参照することができます。$で列名を指定すれば、その列のベクトルが返され、[\"列名\"]の形式で列名を指定すれば、1列のデータフレームとして結果が返されます。 pacific_seiseki$win ## [1] 82 74 74 73 66 64 pacific_seiseki[&quot;lose&quot;] ## lose ## 1 59 ## 2 66 ## 3 68 ## 4 69 ## 5 73 ## 6 78 リストと異なる点は、行列の要素と同様の参照が利用できることです。 # 要素の参照 pacific_seiseki[2, 3] ## [1] 66 # 行の参照 pacific_seiseki[4, ] ## pacific win lose ## 4 ソフトバンク 73 69 # 列の参照 pacific_seiseki[, 3] ## [1] 59 66 68 69 73 78 1.5.1 外部データのデータフレームへのインポート これまでは、Rの基本的な説明のために、ベクトルやデータフレームのオブジェクトをコマンドで作成する方法を示してきましたが、実際の分析では既存の外部データをRにインポートすることが多いです。ここでは、CSVファイルをインポートする方法を紹介します。まず、機械学習関連の情報やサンプルデータを提供している、UCI Machine Learning Repositoryから、ある卸売業者の顧客データをダウンロードしてみましょう。ページを開いたら「Data Folder」のリンクをたどると、CSVファイルへのリンクがあるので、これをダウンロードしてください。ダウンロードしたファイルは作業ディレクトリ（プロジェクトフォルダの場所）に「data」というフォルダを作成して、その中に保存しておいてください。 CSVファイルをデータフレームとしてインポートするには、read.csv()関数を用います。 ws_customer &lt;- read.csv(&quot;./data/Wholesale customers data.csv&quot;) head(ws_customer) ## Channel Region Fresh Milk Grocery Frozen Detergents_Paper Delicassen ## 1 2 3 12669 9656 7561 214 2674 1338 ## 2 2 3 7057 9810 9568 1762 3293 1776 ## 3 2 3 6353 8808 7684 2405 3516 7844 ## 4 1 3 13265 1196 4221 6404 507 1788 ## 5 2 3 22615 5410 7198 3915 1777 5185 ## 6 2 3 9413 8259 5126 666 1795 1451 卸売業者の顧客データのページにおけるAttribute Informationの項目を見てみると、Channelは1がホテル、レストランやカフェ、2が小売の販売チャンネルを意味しています。また、Regionは1がリスボン、2がオポルト、3がその他の地域を表しているようです。これらは名義尺度の変数ですが、 str(ws_customer) ## &#39;data.frame&#39;: 440 obs. of 8 variables: ## $ Channel : int 2 2 2 1 2 2 2 2 1 2 ... ## $ Region : int 3 3 3 3 3 3 3 3 3 3 ... ## $ Fresh : int 12669 7057 6353 13265 22615 9413 12126 7579 5963 6006 ... ## $ Milk : int 9656 9810 8808 1196 5410 8259 3199 4956 3648 11093 ... ## $ Grocery : int 7561 9568 7684 4221 7198 5126 6975 9426 6192 18881 ... ## $ Frozen : int 214 1762 2405 6404 3915 666 480 1669 425 1159 ... ## $ Detergents_Paper: int 2674 3293 3516 507 1777 1795 3140 3321 1716 7425 ... ## $ Delicassen : int 1338 1776 7844 1788 5185 1451 545 2566 750 2098 ... で分かるように、数値型として取り込まれています。これを名義尺度として扱うために、因子型に変換しておきます。 ws_customer$Channel &lt;- factor(ws_customer$Channel, labels = c(&quot;Horeca&quot;, &quot;Retail&quot;)) ws_customer$Region &lt;- factor(ws_customer$Region, labels = c(&quot;Lisbon&quot;, &quot;Oporto&quot;, &quot;Other Region&quot;)) str(ws_customer) ## &#39;data.frame&#39;: 440 obs. of 8 variables: ## $ Channel : Factor w/ 2 levels &quot;Horeca&quot;,&quot;Retail&quot;: 2 2 2 1 2 2 2 2 1 2 ... ## $ Region : Factor w/ 3 levels &quot;Lisbon&quot;,&quot;Oporto&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... ## $ Fresh : int 12669 7057 6353 13265 22615 9413 12126 7579 5963 6006 ... ## $ Milk : int 9656 9810 8808 1196 5410 8259 3199 4956 3648 11093 ... ## $ Grocery : int 7561 9568 7684 4221 7198 5126 6975 9426 6192 18881 ... ## $ Frozen : int 214 1762 2405 6404 3915 666 480 1669 425 1159 ... ## $ Detergents_Paper: int 2674 3293 3516 507 1777 1795 3140 3321 1716 7425 ... ## $ Delicassen : int 1338 1776 7844 1788 5185 1451 545 2566 750 2098 ... "]
]
