[
["index.html", "Rによるデータ解析入門 1 Rの基礎（データ構造とデータ型）", " Rによるデータ解析入門 Tomokazu FUJINO (@nonki1974) 1 Rの基礎（データ構造とデータ型） ここでは、データは数値や文字の集まりであると考えます。Rで標準的に利用できるデータの格納方法（データ構造）は以下の4つです。 ベクトル（vector） 配列・行列（array, matrix） リスト（list） データフレーム（data frame） 一方、個々のデータそのものの種類をデータ型と呼び、Rでは主に以下の3つを利用します。 数値型（numeric） 文字型（charater） 因子型（factor） 特に、因子型は他のプログラミング言語にはないデータ型で、統計解析環境であるRならではのデータ型となっています。\n"],
["vector.html", "1.1 データ構造（1）ベクトル", " 1.1 データ構造（1）ベクトル Rにおける最もシンプルなデータ構造がベクトルです。Rにおいては、単一の数値であっても、大きさ1のベクトルとして扱われます。例えば、以下のような演算を実行した結果の数値も大きさ1のベクトルです。結果に表示される[1]はそのすぐ右にある数値がベクトルの1番目の要素であることを示しています。 3+4 ## [1] 7 sqrt(9) ## [1] 3 sin(pi/6) ## [1] 0.5 多くの要素を持つベクトルの場合、例えば正規乱数を12個生成した結果のベクトルは以下のように表示されます。 rnorm(12) ## [1] -0.4464236 -0.7206500 1.5219659 1.4223438 0.4479338 -0.7520582 ## [7] 1.0609364 -0.1848410 0.9749786 -0.5216983 0.6355070 1.3686260 1.1.1 オブジェクトと変数 Rのコンソールにコマンドを入力すると、Rは何らかの結果をベクトルなどの形で出力してくれます。これらを総称してオブジェクトと呼びます。上のようなコマンドでは出力された結果のオブジェクトは再利用できませんが、変数に代入することで、再利用することができます。例えば、 x &lt;- rnorm(12) とすると、実行結果には何も表示されませんが、変数xの中に実行結果が格納されます。&lt;-（代入演算子と呼びます）は、左辺の変数に右辺の実行結果を代入しなさいという意味になります。つまり、xにrnorm(12)の結果のオブジェクトが格納されたということになります。xの中に何が入っているかを知りたい場合は、コンソールにxと入力します。 x ## [1] -2.0669270 -1.0336867 0.7386809 -0.2207202 2.0434446 0.7572219 ## [7] 0.2528735 -0.6612612 2.0079690 0.3931639 1.0828064 0.1289834 変数名には、文字、数字、ピリオドなどの記号が利用できますが先頭に数字がつくものは使えません。また、大文字と小文字を区別しますので、注意しましょう。実際に分析するときは、分析者にとって分かりやすく、また複数の分析者で分析する場合は他の人が見てもある程度推測できるような変数名にするとよいです。 student_id &lt;- 1200 任意のベクトルを作成する場合は、c()関数1を用います。 x &lt;- c(3, 6, 10) x ## [1] 3 6 10 y &lt;- c(sin(pi/6), sqrt(9)) y ## [1] 0.5 3.0 1.1.2 便利なベクトル作成法 規則的に並んだ数値を要素とするベクトルを作成するには、いくつかの便利な方法があります。 # 1ずつ増加する数列 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 # 同じ数値の繰り返し rep(10, 5) ## [1] 10 10 10 10 10 # 増分を指定した数列（任意の公差をもつ等差数列） seq(1, 2, 0.1) ## [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 1.1.3 ベクトルの演算 ベクトル同士の演算は、2つのベクトルの大きさが同じ場合には要素同士の演算結果がベクトルとして返されます。 x &lt;- c(3, 6, 10) y &lt;- c(3, 2, 5) x + y ## [1] 6 8 15 x - y ## [1] 0 4 5 x * y ## [1] 9 12 50 x / y ## [1] 1 3 2 2つのベクトルの大きさが異なる場合には、小さい方のベクトルの要素が、大きい方と同じ大きさになるまで「リサイクル」されます。以下のコマンドはx^c(2, 2, 2)と同じであると理解しましょう。 x^2 ## [1] 9 36 100 以下のように、大きい方のベクトルの大きさが、小さい方の大きさの定数倍でない場合には警告が出力されます。 z &lt;- c(1, 2) x * z ## Warning in x * z: 長いオブジェクトの長さが短いオブジェクトの長さの倍数になってい ## ません ## [1] 3 12 10 1.1.4 ベクトルの要素の参照 ベクトルの要素を参照する場合は、[]を以下のように使います。 x[2] ## [1] 6 x[2:3] ## [1] 6 10 x[c(1, 3)] ## [1] 3 10 1.1.5 ベクトルに対する便利な関数 複数の処理をまとめたものを関数（function）といいます。関数にはRに元々組み込まれているものもありますし、自分で関数を作ることもできます。関数は 関数名() の形式で呼び出すことができ、()内にオブジェクトを記述することで、関数はそのオブジェクトに対して定められた処理を実行します。()内に記述するオブジェクトを引数（ひきすう）と呼びます。 ベクトルに対しては、以下のような関数がよく用いられます。 # ベクトルの大きさ（要素数）を出力する length(x) ## [1] 3 # 数値ベクトルの合計を出力する sum(x) ## [1] 19 # 数値ベクトルの平均を出力する mean(x) ## [1] 6.333333 # 数値ベクトルの標準偏差（standard deviation）を出力する sd(x) ## [1] 3.511885 cはcombineのcを意味している↩︎ "],
["datatype.html", "1.2 データ型", " 1.2 データ型 1.2.1 数値型と文字型 これまで扱ってきたベクトルに格納しているデータはすべて数値型（numeric）でした。Rでは文字列もデータとして扱うことができ、文字型（character）のデータと呼びます。文字型のデータはダブルクォート\"で囲むことによって表現します。 s &lt;- c(&quot;Kasumi&quot;, &quot;Nadeshiko&quot;, &quot;Kashii&quot;) s ## [1] &quot;Kasumi&quot; &quot;Nadeshiko&quot; &quot;Kashii&quot; ベクトルは、異なるデータ型を混在させることはできません。数値型と文字型が混在したベクトルを作成しようとすると、数値型が文字型に強制変換されます。 c(&quot;Happy&quot;, &quot;New&quot;, &quot;Year&quot;, 2021) ## [1] &quot;Happy&quot; &quot;New&quot; &quot;Year&quot; &quot;2021&quot; class()関数によってオブジェクトの型を確認することができます。 class(x) ## [1] &quot;numeric&quot; class(s) ## [1] &quot;character&quot; 1.2.2 因子型 統計データを扱うR言語独特のデータ型として、因子型（factor）があります。統計学においては、データをその性質から 名義尺度：分類コードやIDとして用いられる数値（血液型や性別など） 順序尺度：名義尺度に順序に関する情報が追加された数値（成績など） 間隔尺度：差の演算結果に意味がある数値（摂氏の気温など） 比例尺度：比の演算結果に意味がある数値（長さ重さなど、0が何もないを表すもの） の4種類に分類するという考え方が一般的です。名義尺度と順序尺度の値を持つ変数のことを質的変数と呼び、因子型は質的変数を扱うためのデータ型となっています。 # 数値型から因子型ベクトルを作成 hakata &lt;- c(0, 2, 3, 1, 3, 2, 1, 2) fhakata &lt;- factor(hakata, levels = 0:3) fhakata ## [1] 0 2 3 1 3 2 1 2 ## Levels: 0 1 2 3 as.numeric(fhakata) ## [1] 1 3 4 2 4 3 2 3 as.numeric(as.character(fhakata)) ## [1] 0 2 3 1 3 2 1 2 この例では、最初に数値型のベクトルを作成し、それをfactor()関数で因子型のベクトルに変換しています。factor()関数のlevels引数は、水準集合のベクトルを指定します。この場合、0という数値が1番目の水準に、1という数値が2番目の水準というように割り当てられることを意味します。 因子型のベクトルの場合、内容を表示するとLevelsの行のように水準集合が合わせて表示されるので、これでデータが因子型かどうかを見分けることができます。as.numeric()関数で因子型ベクトルを数値型ベクトルに変換すると、水準番号が出力されます。元のデータを出力する場合には、as.character()関数で一旦文字型ベクトルに変換してから、数値型ベクトルに変換します。 levels関数を使うと、水準集合を参照したり更新したりすることができます。 levels(fhakata) ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; levels(fhakata) &lt;- c(&quot;天ぷら&quot;, &quot;もつ鍋&quot;, &quot;ラーメン&quot;, &quot;ごまさば&quot;) fhakata ## [1] 天ぷら ラーメン ごまさば もつ鍋 ごまさば ラーメン もつ鍋 ラーメン ## Levels: 天ぷら もつ鍋 ラーメン ごまさば as.numeric(fhakata) ## [1] 1 3 4 2 4 3 2 3 質的変数のデータは、元々は文字列として記録されていることが多いかもしれません。文字型ベクトルをfactor()関数で因子型に変換すると、出現した要素全てが水準集合に含まれるようになります。 fhakata_char &lt;- c(&quot;天ぷら&quot;, &quot;もつ鍋&quot;, &quot;ラーメン&quot;, &quot;ごまさば&quot;, &quot;ラーメン&quot;) factor(fhakata_char) ## [1] 天ぷら もつ鍋 ラーメン ごまさば ラーメン ## Levels: ごまさば もつ鍋 ラーメン 天ぷら 1.2.3 論理型 TRUEとFALSEあるいはそれらの省略形としてTとFは、論理型（logical）と呼ばれるデータ型の値であり、それぞれ真（True）と偽（False）を表現するために用いられます2。 logical_sample &lt;- c(TRUE, FALSE, T, T, F, F) logical_sample ## [1] TRUE FALSE TRUE TRUE FALSE FALSE 1.2.4 欠損値の表現について 実際に統計データを扱う際には、何らかの理由で一部のデータが観測されなかったり、個人情報保護の目的で一部のデータが提供されていなかったりすることがあります。このようなデータを表現するために、Rでは欠損値を意味する値NAが用いられます。 x &lt;- c(2, 5, 10, NA, 3, 2) x ## [1] 2 5 10 NA 3 2 NAを含んだベクトルに対して演算や集計をした場合は次のようになります。 y &lt;- 1:6 x + y ## [1] 3 7 13 NA 8 8 sum(x) ## [1] NA mean(x) ## [1] NA sum()関数やmean()関数で欠損値を無視して計算したい場合には、引数でna.rm = TRUEを指定します。 sum(x, na.rm = TRUE) ## [1] 22 mean(x, na.rm = TRUE) ## [1] 4.4 因子型ベクトルを作成するとき、数値型のベクトルに水準集合に含まれない要素がある場合には、因子型ベクトルの中では欠損値として扱われます。 factor(c(2, 3, 5, 2), levels = 1:4) ## [1] 2 3 &lt;NA&gt; 2 ## Levels: 1 2 3 4 ダブルクォートがついていないので文字型ではないことに注意↩︎ "],
["arrayandmatrix.html", "1.3 データ構造（2）配列と行列", " 1.3 データ構造（2）配列と行列 ベクトルに次元属性を与えることにより、配列として扱えるようになります。 x &lt;- 1:9 x ## [1] 1 2 3 4 5 6 7 8 9 # xを3x3の2次元配列（行列）として扱う dim(x) &lt;- c(3, 3) x ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 x3 &lt;- 1:27 # x3を3x3x3の3次元配列として扱う dim(x3) &lt;- c(3, 3, 3) x3 ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 10 13 16 ## [2,] 11 14 17 ## [3,] 12 15 18 ## ## , , 3 ## ## [,1] [,2] [,3] ## [1,] 19 22 25 ## [2,] 20 23 26 ## [3,] 21 24 27 dim()関数により次元属性が与えられ、引数には各次元の要素数を指定します。配列の各要素は、各次元の要素番号を指定しても、ベクトルとしての要素番号を指定しても参照できます。 x3[1, 2, 1] ## [1] 4 x3[4] ## [1] 4 特に2次元配列である行列を作成する場合には、matrix()関数を使うことができます。 matrix(1:15, ncol = 5, byrow = TRUE) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 ## [3,] 11 12 13 14 15 最初の引数でベクトルを指定しますncolは行列の列数、byrowは行方向にベクトルの要素を並べるかどうかをTRUEかFALSEで指定します（デフォルトはFALSE）。 "],
["list.html", "1.4 データ構造（3）リスト", " 1.4 データ構造（3）リスト ベクトルは単一のデータ型しか保持できませんが、異なるデータ型のベクトルの集まりを1つのオブジェクトとして扱えるデータ構造をリストといいます。リストは、ベクトルだけでなく、別のリストも要素として持つことができます。 season &lt;- 2013 pacific &lt;- c(&quot;楽天&quot;, &quot;西武&quot;, &quot;ロッテ&quot;, &quot;ソフトバンク&quot;, &quot;オリックス&quot;, &quot;日本ハム&quot;) central &lt;- c(&quot;巨人&quot;, &quot;阪神&quot;, &quot;広島&quot;, &quot;中日&quot;, &quot;DeNA&quot;, &quot;ヤクルト&quot;) npb &lt;- list(pacific = pacific, central = central, season = season) npb ## $pacific ## [1] &quot;楽天&quot; &quot;西武&quot; &quot;ロッテ&quot; &quot;ソフトバンク&quot; &quot;オリックス&quot; ## [6] &quot;日本ハム&quot; ## ## $central ## [1] &quot;巨人&quot; &quot;阪神&quot; &quot;広島&quot; &quot;中日&quot; &quot;DeNA&quot; &quot;ヤクルト&quot; ## ## $season ## [1] 2013 リストを新たに作成するにはlist()関数を用います。引数は、要素の参照名 = オブジェクトをカンマ区切りで列挙します。リストのオブジェクト名の後に$要素の参照名をつけて実行すると、指定したリストの要素を直接参照できます。例えば、 npb$pacific ## [1] &quot;楽天&quot; &quot;西武&quot; &quot;ロッテ&quot; &quot;ソフトバンク&quot; &quot;オリックス&quot; ## [6] &quot;日本ハム&quot; また、npb[[1]]のようにすれば、要素番号でリストの要素を参照することもできます。 npb[[2]] ## [1] &quot;巨人&quot; &quot;阪神&quot; &quot;広島&quot; &quot;中日&quot; &quot;DeNA&quot; &quot;ヤクルト&quot; 以下のようにして、文字列として参照名を指定することもできますが、この場合の結果はリストとなります。 npb[&quot;central&quot;] ## $central ## [1] &quot;巨人&quot; &quot;阪神&quot; &quot;広島&quot; &quot;中日&quot; &quot;DeNA&quot; &quot;ヤクルト&quot; class(npb[&quot;central&quot;]) ## [1] &quot;list&quot; 統計計算などを行うRの関数の多くは、その結果をリストの形式で返します。リストの要素の参照名の一覧を見るにはnames()関数を用います。 names(npb) ## [1] &quot;pacific&quot; &quot;central&quot; &quot;season&quot; また、リストの構造を見たい場合は、str()関数を用います。 str(npb) ## List of 3 ## $ pacific: chr [1:6] &quot;楽天&quot; &quot;西武&quot; &quot;ロッテ&quot; &quot;ソフトバンク&quot; ... ## $ central: chr [1:6] &quot;巨人&quot; &quot;阪神&quot; &quot;広島&quot; &quot;中日&quot; ... ## $ season : num 2013 "],
["dataframe.html", "1.5 データ構造（4）データフレーム", " 1.5 データ構造（4）データフレーム データフレームは、同じ長さの複数のベクトルを要素とするリストで、表形式のデータを扱うためのデータ構造です。行列と違い、各列のデータ型は異なっても構いません。データフレームの各行を個体、各列を変数と呼びます。データフレームを作成するには、data.frame()関数を用います。引数はlist()関数と同様です。 pacific_seiseki &lt;- data.frame(pacific = pacific, win = c(82, 74, 74, 73, 66, 64), lose = c(59, 66, 68, 69, 73, 78)) pacific_seiseki ## pacific win lose ## 1 楽天 82 59 ## 2 西武 74 66 ## 3 ロッテ 74 68 ## 4 ソフトバンク 73 69 ## 5 オリックス 66 73 ## 6 日本ハム 64 78 リストと同様に、データフレームの列を参照することができます。$で列名を指定すれば、その列のベクトルが返され、[\"列名\"]の形式で列名を指定すれば、1列のデータフレームとして結果が返されます。 pacific_seiseki$win ## [1] 82 74 74 73 66 64 pacific_seiseki[&quot;lose&quot;] ## lose ## 1 59 ## 2 66 ## 3 68 ## 4 69 ## 5 73 ## 6 78 リストと異なる点は、行列の要素と同様の参照が利用できることです。 # 要素の参照 pacific_seiseki[2, 3] ## [1] 66 # 行の参照 pacific_seiseki[4, ] ## pacific win lose ## 4 ソフトバンク 73 69 # 列の参照 pacific_seiseki[, 3] ## [1] 59 66 68 69 73 78 # 複数列の参照: 2列目から3列目 pacific_seiseki[, 2:3] ## win lose ## 1 82 59 ## 2 74 66 ## 3 74 68 ## 4 73 69 ## 5 66 73 ## 6 64 78 # 複数列の参照: 1列目と3列目 pacific_seiseki[, c(1, 3)] ## pacific lose ## 1 楽天 59 ## 2 西武 66 ## 3 ロッテ 68 ## 4 ソフトバンク 69 ## 5 オリックス 73 ## 6 日本ハム 78 データフレームの行数と列数は以下のようにして確認することができます。 # 行数 nrow(pacific_seiseki) ## [1] 6 # 列数 ncol(pacific_seiseki) ## [1] 3 # 同時に dim(pacific_seiseki) ## [1] 6 3 RStudioを利用している場合、Environment Paneにオブジェクトの一覧が表示されますが、その中でデータフレームのオブジェクトをクリックすると、スプレッドシートの形式で、データのプレビューが表示され、簡易的なデータの検索やソートができます。 1.5.1 外部データのデータフレームへのインポート これまでは、Rの基本的な説明のために、ベクトルやデータフレームのオブジェクトをコマンドで作成する方法を示してきましたが、実際の分析では既存の外部データをRにインポートすることが多いです。ここでは、CSVファイルをインポートする方法を紹介します。 fukuoka2015.csvは2015年の福岡県内市区町村の人口および世帯数のデータです。リンクをクリックするととブラウザでファイルの中身が表示されるので、作業ディレクトリ（プロジェクトフォルダの場所）に「data」というフォルダを作成して、その中に保存しておいてください（右クリック-&gt;「名前を付けて保存」）。CSVファイルをデータフレームとしてインポートするには、read.csv()関数を用います。 fukuoka2015 &lt;- read.csv(&quot;./data/fukuoka2015.csv&quot;, encoding = &quot;UTF-8&quot;) # データフレームの最初の6行を表示 head(fukuoka2015) ## area_code 地域 総面積 人口総数 昼間人口 世帯数 ## 1 40101 門司区 7367 99637 97946 43082 ## 2 40103 若松区 7131 82844 82591 33692 ## 3 40105 戸畑区 1661 59116 70519 27797 ## 4 40106 小倉北区 3923 181878 224589 91253 ## 5 40107 小倉南区 17174 212850 190913 88497 ## 6 40108 八幡東区 3626 68844 73391 31442 encoding引数に、読み込むファイルの文字コード（このファイルの場合UTF-8）を指定します。この引数を指定しない場合、システム標準の文字コード（Windowsの場合SHIFT-JIS、Macの場合UTF-8）で読み込まれます。ファイルの文字コードと読み込もうとする文字コードに相違がある場合、文字化けが発生します。UTF-8のファイルを読み込む場合、Macの環境では、encoding引数の指定は必要ありません。 特に引数を指定しない場合、csvファイルの中で、数値のみからなるの列は数値型、それ以外は文字型として読み込まれます。fukuoka2015の場合、area_codeはコード番号を表すので名義尺度ですが、数値型として読み込まれるので、必要に応じて因子型に変換します。また、地域は文字型として読み込まれるので、こちらも必要に応じて因子型に変換します（後述）。 str(fukuoka2015) ## &#39;data.frame&#39;:\t68 obs. of 6 variables: ## $ area_code: int 40101 40103 40105 40106 40107 40108 40109 40131 40132 40133 ... ## $ 地域 : chr &quot;門司区&quot; &quot;若松区&quot; &quot;戸畑区&quot; &quot;小倉北区&quot; ... ## $ 総面積 : int 7367 7131 1661 3923 17174 3626 8313 6936 3163 1540 ... ## $ 人口総数 : int 99637 82844 59116 181878 212850 68844 256117 306015 228441 192688 ... ## $ 昼間人口 : int 97946 82591 70519 224589 190913 73391 243568 303352 381926 296992 ... ## $ 世帯数 : int 43082 33692 27797 91253 88497 31442 110562 141682 138832 116186 ... "]
]
